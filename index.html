<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>【AI連携・世代交代対応版】トーナメント表</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&family=Noto+Serif+JP:wght@700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <style>
        body { font-family: 'Inter', 'Noto Sans JP', sans-serif; background-color: #f0f2f5; }
        .setup-card, .display-card { background-color: #fff; padding: 24px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); margin-bottom: 24px; }
        #main-bracket-container { display: flex; justify-content: center; padding: 20px; font-size: 12px; overflow-x: auto; border: 1px solid #e5e7eb; background-color: #f9fafb; border-radius: 8px;}
        .bracket-half { display: flex; }
        .bracket-half.right { flex-direction: row-reverse; }
        .bracket-final { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 0 10px; flex-shrink: 0; min-width: 60px; }
        .bracket-final .final-matchup { border: 2px solid #f59e0b; background-color: #fffbeb; border-radius: 6px; padding: 5px; margin-top: 10px; }
        .bracket-final .winner-box { font-weight: bold; color: #b45309; text-align: center; padding: 10px 20px; white-space: nowrap; font-size: 1.25rem; }
        .bracket-final .final-title { font-weight: 600; color: #4b5563; margin-bottom: 10px; writing-mode: vertical-rl; letter-spacing: 2px; }
        .round { display: flex; flex-direction: column; justify-content: space-around; flex-shrink: 0; width: 180px; padding: 0 10px; }
        .matchup { margin: 8px 0; position: relative; display: flex; flex-direction: column; justify-content: center; flex-grow: 1; }
        .team-slot { display: flex; align-items: center; background-color: #ffffff; border: 1px solid #e5e7eb; border-radius: 4px; margin-bottom: 4px; transition: background-color 0.3s; position: relative; }
        .team-slot:last-of-type { margin-bottom: 0; }
        .team-name { flex-grow: 1; padding: 6px 8px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .team-name .rank { font-weight: bold; margin-right: 4px; }
        .team-name .rank-A { color: #ef4444; }
        .team-name .rank-B { color: #f97316; }
        .team-name .rank-C { color: #eab308; }
        .team-name .rank-D { color: #3b82f6; }
        .team-name .rank-E { color: #6b7280; }
        .team-name.seed { font-weight: bold; color: #ca8a04; }
        .score-input { width: 40px; padding: 6px 4px; border-left: 1px solid #e5e7eb; text-align: center; background-color: #fff; }
        .win-btn { background-color: #d1d5db; color: #fff; border: none; padding: 6px 8px; border-top-right-radius: 3px; border-bottom-right-radius: 3px; cursor: pointer; font-weight: bold; transition: background-color 0.2s; }
        .team-slot:not(.empty) .win-btn { background-color: #3b82f6; }
        .team-slot:not(.empty):hover .win-btn { background-color: #2563eb; }
        .team-slot.winner { background-color: #dbeafe; border-color: #93c5fd; font-weight: 600; }
        .team-slot.loser { background-color: #f3f4f6; opacity: 0.6; }
        .team-slot.empty .team-name { color: #9ca3af; }
        .team-slot.empty .score-input, .team-slot.empty .win-btn, .team-slot.empty .details-btn { display: none; }
        .matchup::after { content: ''; position: absolute; top: 50%; width: 10px; height: 2px; background-color: #cbd5e1; }
        .bracket-half.left .matchup::after { right: -10px; }
        .bracket-half.right .matchup::after { left: -10px; }
        .round.subsequent-round .matchup::before { content: ''; position: absolute; top: -8px; height: calc(100% + 16px); width: 2px; background-color: #cbd5e1; }
        .bracket-half.left .round.subsequent-round .matchup::before { right: -10px; }
        .bracket-half.right .round.subsequent-round .matchup::before { left: -10px; }
        .hidden { display: none; }
        .news-article { border-left: 4px solid #3b82f6; cursor: pointer; transition: background-color 0.2s; }
        #modal-bg { background-color: rgba(0,0,0,0.5); }
        .confirm-modal, .details-modal, .save-load-modal, .newspaper-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center; z-index: 100; }
        .confirm-modal-content, .details-modal-content, .save-load-modal-content, .newspaper-modal-content { background-color: white; padding: 24px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        .details-modal-content { width: 95%; max-width: 1000px; max-height: 90vh; overflow-y: auto;}
        .save-load-modal-content { width: 95%; max-width: 500px; }
        .newspaper-modal-content { width: 95%; max-width: 800px; max-height: 95vh; overflow-y: auto; }
        .confirm-modal-content { text-align: center; }
        .loader { text-align: center; padding: 20px; font-style: italic; color: #6b7280; }
        .details-btn { background-color: #6b7280; color: white; font-size: 10px; padding: 2px 6px; border-radius: 4px; margin-left: auto; margin-right: 2px; }
        .details-btn:hover { background-color: #4b5563; }
        .matchup-footer { text-align: center; margin-top: 2px; display: flex; justify-content: center; align-items: center; gap: 4px;}
        .stats-table { width: 100%; border-collapse: collapse; font-size: 12px; }
        .stats-table th, .stats-table td { border: 1px solid #e5e7eb; padding: 4px 6px; text-align: center; }
        .stats-table th { background-color: #f3f4f6; }
        .stats-table input { width: 100%; border: none; text-align: center; background: transparent;}
        .stats-table input:focus { outline: 1px solid #3b82f6; }
        .modal-body-scroll {
            max-height: 70vh;
            overflow-y: auto;
        }
        #save-code-output {
            word-break: break-all;
            background-color: #f3f4f6;
            padding: 8px;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            user-select: all;
        }
        .bbs-comment {
            background-color: #ffffff;
            border: 1px solid #e5e7eb;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .match-summary-input {
            resize: none;
            height: 40px;
        }
        .article-error {
            background-color: #fee2e2;
            border-left: 4px solid #ef4444;
            color: #b91c1c;
            padding: 1rem;
            border-radius: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .retry-btn {
            background-color: #ef4444;
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 0.375rem;
            font-weight: 600;
            cursor: pointer;
        }
        .retry-btn:hover {
            background-color: #dc2626;
        }
        .namco-news-item {
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .namco-news-tag {
            background-color: #f97316;
            color: white;
            font-size: 0.75rem;
            padding: 2px 8px;
            border-radius: 9999px;
            margin-left: 8px;
        }
        
.region-map {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 20px;
        }
        .region-column {
            background-color: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            overflow: hidden; /* 角丸デザインのため */
        }
        .region-header {
            padding: 12px 16px;
            background-color: #f9fafb;
            border-bottom: 1px solid #e5e7eb;
        }
        .region-title {
            font-weight: 600;
            font-size: 1rem;
            color: #1f2937;
        }
        .region-stats {
            font-size: 0.8rem;
            color: #4b5563;
        }
        .region-team-list {
            list-style: none;
            padding: 8px 16px 16px 16px;
            margin: 0;
        }
        .region-team {
            display: flex;
            align-items: center;
            padding: 6px 0;
            font-size: 0.9rem;
            transition: background-color 0.2s;
        }
        .team-surviving {
            font-weight: 500;
            color: #1f2937;
        }
        /* 生き残っているチーム名の前に緑の丸を追加 */
        .team-surviving::before {
            content: '';
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #10b981; /* Green */
            margin-right: 8px;
        }
        .team-eliminated {
            color: #9ca3af;
            text-decoration: line-through;
            opacity: 0.7;
        }
        /* 敗退したチーム名の前にグレーの丸を追加 */
        .team-eliminated::before {
            content: '';
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #d1d5db; /* Gray */
            margin-right: 8px;
        }
        /* Newspaper Styles */
        .newspaper-container { font-family: 'Noto Serif JP', serif; padding: 2rem; background-color: #fdfdf8; }
        .newspaper-early { filter: grayscale(100%); border: 2px solid #333; }
        .newspaper-late { border: 2px solid #a10e25; }
        .newspaper-header { text-align: center; border-bottom: 4px double #333; padding-bottom: 0.5rem; margin-bottom: 1rem; }
        .newspaper-title { font-size: 1.2rem; font-weight: 700; }
        .newspaper-date { font-size: 0.8rem; }
        .newspaper-content { display: flex; gap: 1.5rem; }
        .newspaper-main-headline { writing-mode: vertical-rl; text-orientation: mixed; font-size: 2.5rem; font-weight: 700; letter-spacing: 0.2em; border-right: 2px solid #333; padding-right: 1rem; margin-right: 1rem; }
        .newspaper-late .newspaper-main-headline { color: #a10e25; border-right-color: #a10e25;}
        .newspaper-body-content { flex-grow: 1; }
        .newspaper-sub-headline { font-size: 1.5rem; font-weight: 700; margin-bottom: 1rem; border-bottom: 1px solid #666; padding-bottom: 0.5rem; }
        .newspaper-late .newspaper-sub-headline { color: #333; }
        .newspaper-text { font-family: 'Noto Sans JP', sans-serif; column-count: 3; column-gap: 1.5rem; text-align: justify; font-size: 0.9rem; line-height: 1.8; }
        .newspaper-early .newspaper-text { column-count: 2; }
        .newspaper-score-box { border: 2px solid #333; padding: 1rem; text-align: center; margin-top: 1rem; }
        .newspaper-score-box h3 { font-weight: 700; margin-bottom: 0.5rem; font-size: 1.1rem; }
        .newspaper-score-box .score { font-size: 2rem; font-weight: 700; }
        .newspaper-late .newspaper-score-box { background-color: #fff8f8; border-color: #a10e25; }
        .newspaper-image-placeholder { width: 100%; height: 200px; background-color: #e0e0e0; margin: 1rem 0; display: flex; align-items: center; justify-content: center; font-family: 'Noto Sans JP', sans-serif; color: #888; border: 1px dashed #aaa; }
   
 </style>
</head>
<body class="p-4 md:p-8">

    <div id="app-container" class="max-w-full mx-auto">
        <div class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-800">AI記者付きトーナメント表</h1>
            <p id="tournament-year-display" class="text-gray-600 mt-2">（64チーム版・AI連携）</p>
        </div>

        <div id="setup" class="setup-card">
             <div class="w-full">
                 <h2 class="text-xl font-semibold text-gray-700 mb-4 border-b pb-2">参加チーム (64チーム)</h2>
                 <textarea id="teams-list" class="w-full h-96 p-3 border border-gray-300 rounded-lg" readonly></textarea>
             </div>
             <div class="mt-8 text-center">
                 <button id="resume-btn" class="bg-green-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-green-700 shadow-md mb-4 w-full md:w-auto">
                    再開（合い言葉入力）
                 </button>
                 <button id="generate-btn" class="bg-blue-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-blue-700 shadow-md w-full md:w-auto">
                     新しいトーナメントを開始
                 </button>
             </div>
        </div>

        <div id="tournament-display" class="hidden">
<div id="autumn-phase-container" class="display-card hidden">
    </div>
<div id="autumn-controls" class="text-center my-4 hidden">
    <button id="start-playoff-btn" class="bg-purple-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-purple-700 shadow-md hidden">
        5位代表決定戦へ進む
    </button>
    <button id="start-main-tournament-btn" class="bg-teal-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-teal-700 shadow-md hidden">
        県大会本戦へ進む
    </button>
</div>
   <div id="region-map-section" class="display-card hidden">
                <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">地区別 勝ち残り状況</h2>
                <div id="region-map-container" class="w-full"></div>
            </div>
             <div id="namco-news-section" class="hidden display-card border-2 border-orange-400">
                 <h2 class="text-xl font-bold text-orange-600 mb-3 text-center">ナムコグループからのお知らせ</h2>
                 <div id="namco-news-content" class="space-y-2"></div>
             </div>
            <div class="flex justify-between items-start mb-4">
                <div>
                    <button id="generate-summary-btn" class="hidden bg-yellow-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-yellow-600 shadow-md">
<button id="directory-btn" class="bg-purple-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-700 shadow-md ml-2">
    選手名鑑
</button>
                        ここまでの大会ハイライト記事を生成
                    </button>
                    <button id="next-tournament-btn" class="hidden bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 shadow-md">
                        次の大会へ進む
                    </button>
                </div>
               <div class="ml-auto">
                    <div class="flex items-center justify-end space-x-2">
                        <button id="skip-r1-btn" class="hidden bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 shadow-md">1回戦スキップ</button>
                        <button id="skip-r2-btn" class="hidden bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 shadow-md">2回戦スキップ</button>
                        <button id="skip-r3-btn" class="hidden bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 shadow-md">3回戦スキップ</button>
                        <span id="save-feedback" class="text-gray-600 font-bold opacity-0 transition-opacity duration-500"></span>
                        <button id="save-btn" class="bg-sky-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-sky-700 shadow-md">セーブ</button>
                        <button id="reset-btn" class="bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700 shadow-md">リセット</button>
                    </div>
                    <div id="skip-loader-container" class="h-6 text-right mt-1">
                         <span id="skip-loader" class="hidden text-sm text-gray-600 font-bold">試合を進行しています...</span>
                    </div>
                </div>
            </div>
            <div class="display-card">
                <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">トーナメント表</h2>
                <div class="bg-blue-100 border-l-4 border-blue-500 text-blue-700 p-4 mb-4 rounded-md text-sm">
                    <p><b>PCでの表示について:</b> トーナメント表の全体が表示されない場合は、表のエリア内でマウスのホイールを回しながら <b>Shiftキー</b> を押すか、表の下に表示されるスクロールバーを直接ドラッグすることで、左右にスクロールできます。</p>
                </div>
                <div id="main-bracket-container"></div>
            </div>
            <div id="news-section" class="display-card">
                <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">注目ニュース</h2>
                <div id="news-articles" class="space-y-4">
                    <p class="text-gray-500 text-center">まだニュースはありません。</p>
                </div>
            </div>
             <div id="daiya-bbs-section" class="hidden display-card border-4 border-green-600">
                 <h2 id="daiya-bbs-title" class="text-2xl font-bold text-green-800 mb-4 text-center">【特設】代矢東 応援掲示板</h2>
                 <div id="daiya-bbs-comments" class="space-y-3">
                     <p class="text-gray-500 text-center">まだ反応はありません。</p>
                 </div>
             </div>
             <div id="bbs-section" class="display-card">
                 <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">掲示板の反応</h2>
                 <div id="bbs-comments" class="space-y-3">
                     <p class="text-gray-500 text-center">まだ反応はありません。</p>
                 </div>
             </div>
        </div>
    </div>

    <!-- Modals -->
    <div id="news-modal" class="fixed inset-0 z-50 hidden items-center justify-center">
        <div id="modal-bg" class="absolute inset-0"></div>
        <div class="relative bg-white rounded-lg shadow-xl max-w-2xl w-full m-4">
            <div class="p-6 modal-body-scroll">
                <h3 id="modal-title" class="text-2xl font-bold text-gray-900"></h3>
                <div id="modal-meta" class="text-gray-400 text-sm mt-2 flex items-center gap-4"></div>
                <p id="modal-body" class="mt-4 text-gray-600 whitespace-pre-wrap"></p>
            </div>
            <button id="modal-close" class="absolute top-3 right-3 text-gray-400 hover:text-gray-600">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>
    
    <div id="confirm-modal" class="confirm-modal hidden">
        <div class="confirm-modal-content">
            <p id="confirm-modal-text" class="mb-4 text-lg"></p>
            <button id="confirm-ok" class="bg-red-600 text-white px-6 py-2 rounded-lg mr-2">はい</button>
            <button id="confirm-cancel" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">いいえ</button>
        </div>
    </div>

    <div id="details-modal" class="details-modal hidden">
        <div class="details-modal-content">
            <h3 class="text-xl font-bold mb-4 text-center">試合詳細入力</h3>
            <div id="details-modal-body" class="space-y-6"></div>
            <div class="mt-6 text-center">
                <button id="details-save" class="bg-blue-600 text-white px-6 py-2 rounded-lg mr-2">保存</button>
                <button id="details-close" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">閉じる</button>
            </div>
        </div>
    </div>
    
    <div id="save-load-modal" class="save-load-modal hidden">
        <div class="save-load-modal-content">
            <div class="flex border-b">
                <button id="save-tab-btn" class="px-4 py-2 font-semibold border-b-2 border-blue-500">セーブ (合い言葉の発行)</button>
                <button id="load-tab-btn" class="px-4 py-2 text-gray-500">ロード (合い言葉の入力)</button>
            </div>
            <div id="save-tab-content" class="py-4">
                <p class="text-sm mb-2">現在の進行状況を保存するための「合い言葉」を発行します。下のボタンを押してください。</p>
                <button id="generate-save-code-btn" class="w-full bg-blue-600 text-white py-2 rounded hover:bg-blue-700">合い言葉を発行</button>
                <div id="save-code-area" class="hidden mt-4">
                    <p class="text-sm font-bold text-green-600">合い言葉が発行されました。以下をコピーして安全な場所に保管してください。</p>
                    <div class="flex items-center mt-2">
                        <div id="save-code-output" class="flex-grow text-xs"></div>
                        <button id="copy-save-code-btn" class="ml-2 bg-gray-200 px-3 py-1 rounded text-xs font-semibold hover:bg-gray-300">コピー</button>
                    </div>
                    <p id="copy-feedback" class="text-xs text-green-600 mt-1 h-4"></p>
                </div>
            </div>
            <div id="load-tab-content" class="py-4 hidden">
                <p class="text-sm mb-2">保存した「合い言葉」を以下に貼り付けてください。</p>
                <textarea id="load-code-input" placeholder="合い言葉をここに貼り付け" class="w-full h-32 p-2 border rounded mb-2"></textarea>
                <button id="load-from-code-btn" class="w-full bg-green-600 text-white py-2 rounded hover:bg-green-700">このデータで再開する</button>
            </div>
             <div class="mt-4 text-right">
       <div id="player-directory-modal" class="fixed inset-0 z-50 hidden items-center justify-center bg-black bg-opacity-50">
    <div class="bg-white rounded-lg shadow-xl max-w-4xl w-full m-4">
        <div class="p-4 border-b flex justify-between items-center">
            <h3 id="directory-modal-title" class="text-2xl font-bold text-gray-900">選手名鑑</h3>
            <button id="directory-modal-close" class="text-gray-400 hover:text-gray-600">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        <div id="directory-modal-content" class="p-6 modal-body-scroll" style="max-height: 80vh;">
            </div>
    </div>
</div>         
<button id="save-load-close" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">閉じる</button>
            </div>
        </div>
    </div>

    <!-- Newspaper Modal -->
    <div id="newspaper-modal" class="newspaper-modal hidden">
        <div class="newspaper-modal-content">
            <div id="newspaper-modal-body"></div>
            <div class="mt-4 text-center">
                <button id="newspaper-close" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">閉じる</button>
            </div>
        </div>
    </div>


    <script type="module">
    // --- DOM Elements ---
    const setupEl = document.getElementById('setup');
    const tournamentDisplayEl = document.getElementById('tournament-display');
    const teamsTextarea = document.getElementById('teams-list');
    const generateBtn = document.getElementById('generate-btn');
    const resumeBtn = document.getElementById('resume-btn');
    const resetBtn = document.getElementById('reset-btn');
    const nextTournamentBtn = document.getElementById('next-tournament-btn');
    const saveBtn = document.getElementById('save-btn');
    const saveFeedback = document.getElementById('save-feedback');
    const mainBracketContainer = document.getElementById('main-bracket-container');
    const newsContainer = document.getElementById('news-articles');
    const bbsCommentsContainer = document.getElementById('bbs-comments');
    const daiyaBbsSection = document.getElementById('daiya-bbs-section');
    const daiyaBbsTitle = document.getElementById('daiya-bbs-title');
    const daiyaBbsCommentsContainer = document.getElementById('daiya-bbs-comments');
    const namcoNewsSection = document.getElementById('namco-news-section');
    const namcoNewsContent = document.getElementById('namco-news-content');
    const tournamentYearDisplay = document.getElementById('tournament-year-display');
    const generateSummaryBtn = document.getElementById('generate-summary-btn');
    const skipR1Btn = document.getElementById('skip-r1-btn');
    const skipR2Btn = document.getElementById('skip-r2-btn');
    const skipR3Btn = document.getElementById('skip-r3-btn');
    const skipLoader = document.getElementById('skip-loader');

    // Modals
    const newsModal = document.getElementById('news-modal');
    const modalBg = document.getElementById('modal-bg');
    const modalClose = document.getElementById('modal-close');
    const confirmModal = document.getElementById('confirm-modal');
    const detailsModal = document.getElementById('details-modal');
    const saveLoadModal = document.getElementById('save-load-modal');
    const saveTabBtn = document.getElementById('save-tab-btn');
    const loadTabBtn = document.getElementById('load-tab-btn');
    const saveTabContent = document.getElementById('save-tab-content');
    const loadTabContent = document.getElementById('load-tab-content');
    const generateSaveCodeBtn = document.getElementById('generate-save-code-btn');
    const loadFromCodeBtn = document.getElementById('load-from-code-btn');
    const saveLoadCloseBtn = document.getElementById('save-load-close');
    const copySaveCodeBtn = document.getElementById('copy-save-code-btn');
    const newspaperModal = document.getElementById('newspaper-modal');
    const newspaperModalBody = document.getElementById('newspaper-modal-body');
    const newspaperCloseBtn = document.getElementById('newspaper-close');
    const autumnPhaseContainer = document.getElementById('autumn-phase-container');
    const autumnControls = document.getElementById('autumn-controls');
    const startPlayoffBtn = document.getElementById('start-playoff-btn');
    const startMainTournamentBtn = document.getElementById('start-main-tournament-btn');
    
    // --- State Management ---
    let tournamentState = {};
    let currentMatchIdForDetails = null;

    // --- Team Master Data ---
    const TEAM_DATA = {
        "西浦": { name_yomi: "にしうら", region: "西部", type: "公立", deviation: 52, best: "県大会ベスト16", last: "県大会ベスト16", info: "三年前にできた新設校。歴史は浅いが驚異の躍進が光る。" },
        "本島越谷": { name_yomi: "もとじまこしがや", region: "東部", type: "私立", deviation: 32, best: "県大会ベスト8", last: "初戦敗退", info: "近年野球部に力を入れている新興私立。プロ野球選手を外部コーチに招聘している。" },
        "海堂学園": { name_yomi: "かいどうがくえん", region: "西部", type: "私立", deviation: 40, best: "県大会ベスト8", last: "県大会2回戦", info: "かつては甲子園を優勝し県内で海堂ブームを巻き起こした。が、それも30年前の話であり、今となってはかつての輝きは見えない古豪と化している" },
        "初星学園": { name_yomi: "はつぼしがくえん", region: "中部", type: "私立", deviation: 58, best: "県大会2回戦", last: "初戦敗退", info: "県に複数あるナムコグループの設立した学校の一つ。野球部は設立したばかりで、部員数は多くないものの、そのポテンシャルは高く。毎年上位に食い込んでくる。野球部よりも学校としての特色であるアイドル科目当てに受験する人が多い。" },
        "緑山": { name_yomi: "みどりやま", region: "中部", type: "公立", deviation: 45, best: "なし", last: "なし", info: "今年初めて野球部を新しく創立した公立校。全員1年生で経験は浅いが、ガッツで他校に食らいつきたい" },
        "765総合高校": { name_yomi: "なむこそうごう", region: "中部", type: "私立", deviation: 55, best: "県大会ベスト16", last: "県大会2回戦", info: "初星学園と経営母体は同じナムコグループであるがこちらは野球部に力を入れている。2年前には県を制覇し甲子園でもベスト16まで進んだ経験もあり、当時1年生からレギュラーだったメンバーが再び甲子園を目指し、聖地を知るものとしてチームを引っ張っている。", popularity: true },
        "鷲尾": { name_yomi: "わしお", region: "中部", type: "公立", deviation: 53, best: "県大会ベスト16", last: "初戦敗退", info: "普通の公立校。昔は地区一番の進学校だったが立地の悪さと少子化に伴い偏差値も低下、近年は毎年定員割れを起こしており、廃校も時間の問題である。野球部もベスト16が過去に一度きりでパッとしない。" },
        "283学園": { name_yomi: "つばさがくえん", region: "西部", type: "私立", deviation: 60, best: "甲子園1回戦", last: "県優勝(甲子園初戦敗退)", info: "ナムコグループが15年前に設立した高校。昨年は2年生エース姫川が投打にわたりチームを引っ張り創部初の優勝を成し遂げた。昨年のレギュラーも複数残っており、大会連覇に向け、前回王者が牙を研ぐ。", popularity: true },
        "土理琉工業": { name_yomi: "どりるこうぎょう", region: "西部", type: "公立", deviation: 41, best: "県大会2回戦", last: "初戦敗退", info: "県で唯一の工業高校。野球部はあまり強くない。" },
        "実践学園": { name_yomi: "じっせんがくえん", region: "中部", type: "私立", deviation: 63, best: "甲子園出場", last: "初戦敗退", info: "私立の進学校。野球部はあまり強くないが、サッカー部が強く、野球部の大会時には有志でサッカー部が応援に駆け付けオリジナルのサッカースタイルの応援で盛り立てる。これを実践学園の名物として見に来る隠れファンも多い。" },
        "武蔵野第一": { name_yomi: "むさしのだいいち", region: "東部", type: "公立", deviation: 55, best: "県大会ベスト8", last: "県大会ベスト8", info: "公立進学校。野球部はここ数年初戦敗退が続いていたが、140km左腕の榛名の台頭により昨年の夏は創部初のベスト8に進出した。2年生となった榛名の速球は健在であり、今年も武蔵野旋風に期待したい。" },
        "代矢東": { name_yomi: "だいやひがし", region: "東部", type: "公立", deviation: 65, best: "甲子園3回戦", last: "県大会ベスト4", info: "老若男女問わず地元民に愛される創立93年を迎える伝統校。近年は他校の私立との選手獲得競争に一つ遅れをとっており、甲子園からは遠ざかっているが、歴史は厚く、甲子園には通算13回出場している。そのため公立に似合わず多額の寄付により設備は充実している。頭もよくスポーツも強いため、県民の憧れである。代矢東の試合がある際には球場に多くのOBが駆け付け、大応援団を結成し、相手を圧倒する。近年はナムコグループが県内を牛耳りかけているため、公立の希望の星としてメディアに取り上げられることも多い。", popularity: true },
        "風林大尾": { name_yomi: "ふうりんたいび", region: "東部", type: "私立", deviation: 59, best: "甲子園2回戦", last: "初戦敗退", info: "私立の進学校。昔は野球部が強かったが監督の不祥事により一度は廃部危機にまでなった。昔よりは勢いはないが、経営体制を一新しイメージのクリーン化に努めた結果、部員数も回復してきた。そろそろ古豪として、復活の狼煙をあげたい。" },
        "青道": { name_yomi: "せいどう", region: "西部", type: "私立", deviation: 54, best: "甲子園準優勝", last: "県大会ベスト8", info: "28年前に甲子園準優勝の経験もある強豪校。毎年ベスト8までは安定して出場するが、近年はそこが壁となり突破できずにいる。今年こそは甲子園へ、と学校側のサポートも厚い。", popularity: true },
        "聖秀": { name_yomi: "せいしゅう", region: "東部", type: "私立", deviation: 48, best: "なし", last: "なし", info: "野球部創部一年目の新米野球部。部員は10人と少ないが主将で3番を打つ茂野が攻守でチームを引っ張る。" },
        "大船渡": { name_yomi: "おおふなと", region: "東部", type: "公立", deviation: 51, best: "甲子園出場", last: "初戦敗退", info: "甲子園出場ほどではないものの、公立校の中ではれっきとした実力をもつ中堅校。今年はプロ注目右腕の斎藤を擁し甲子園初出場を狙う。" },
        "美城学園": { name_yomi: "みしろがくえん", region: "中部", type: "私立", deviation: 61, best: "県大会ベスト4", last: "県大会2回戦", info: "ナムコグループを母体とする高校。こちらの野球部は中堅校として県内でなお馳せており、組み合わせ次第では甲子園も狙える実力を持っている。近年はほかの高校にリソースを持っていかれ、ナムコグループの中だと低迷気味である。" },
        "東大学園": { name_yomi: "とうだいがくえん", region: "中部", type: "私立", deviation: 78, best: "県大会2回戦", last: "初戦敗退", info: "全国的に有名な進学校。野球部は弱いが、持ち前の頭脳を活かしたデータ野球で強豪校に食らいつきたい。" },
        "金足農業": { name_yomi: "かなあしのうぎょう", region: "東部", type: "公立", deviation: 42, best: "甲子園準優勝", last: "県大会2回戦", info: "数年前には金農フィーバーで一世を風靡したが、その後は低迷している。もう一度輝くべく甲子園を狙っている。", popularity: true },
        "御殿場南": { name_yomi: "ごてんばみなみ", region: "東部", type: "公立", deviation: 54, best: "県大会ベスト16", last: "県大会ベスト16", info: "山間部にある公立校。毎年初戦敗退が続いていたが昨年は11年ぶり初戦突破を皮切りに50年ぶりのベスト16に進出。今年も躍進へ期待がかかる。" },
        "雷門南": { name_yomi: "らいもんみなみ", region: "西部", type: "公立", deviation: 61, best: "甲子園2回戦", last: "県大会ベスト4", info: "代矢東と並ぶ県内二大大規模公立のひとつ。代矢東が文武両道ならばこちらはスポーツが盛んである。特にラグビー部サッカー部は全国制覇を成し遂げており、野球部の躍進にも期待がかかる。" },
        "横須賀": { name_yomi: "よこすか", region: "西部", type: "公立", deviation: 55, best: "甲子園出場", last: "県大会2回戦", info: "海辺にある公立校。野球部としては中堅校である。" },
        "今治学園": { name_yomi: "いまばりがくえん", region: "西部", type: "私立", deviation: 52, best: "県大会ベスト16", last: "県大会ベスト16", info: "体育科のみの通信制私立。着々と結果を出しており、昨年はベスト16" },
        "田辺水産": { name_yomi: "たなべすいさん", region: "中部", type: "公立", deviation: 44, best: "県大会ベスト4", last: "県大会2回戦", info: "貴重な水産高校。野球部も一昨年はベスト4へ進出したりと勢いがある。試合時のスタンドには大漁とかかれた大きな旗が舞う。" },
        "八千代": { name_yomi: "やちよ", region: "中部", type: "公立", deviation: 59, best: "県大会ベスト8", last: "初戦敗退", info: "大きな市にある。中規模公立。野球部としての特色はこれといってないが、人口が多い地域のため、毎年それなりのレベルの新入生が集まる。" },
        "日南学園": { name_yomi: "にちなんがくえん", region: "西部", type: "私立", deviation: 46, best: "甲子園ベスト4", last: "初戦敗退", info: "野球部はそこそこつよいがガラが悪く、メディア受けが悪い。" },
        "薬師": { name_yomi: "やくし", region: "東部", type: "私立", deviation: 50, best: "甲子園出場", last: "県大会2回戦", info: "普通の私立高校だが、たまに上位にくる。" },
        "稲城実業": { name_yomi: "いなしろじつぎょう", region: "西部", type: "私立", deviation: 57, best: "甲子園優勝", last: "県大会ベスト8", info: "野球部に力を入れている私立。毎年ベスト8の壁に苦しんでいるが、成宮、平野、赤松の三枚看板で甲子園を目指す。", popularity: true },
        "市大三": { name_yomi: "しだいさん", region: "西部", type: "私立", deviation: 56, best: "甲子園出場", last: "県大会2回戦", info: "こちらもベスト８や16にはよく顔をだす私立校。総合力はあるもののパッとしない。" },
        "極亜久": { name_yomi: "ごくあく", region: "東部", type: "私立", deviation: 38, best: "甲子園出場", last: "初戦敗退", info: "むかしは甲子園にも出場したことある学校。今は少子化のあおりを受け、ただの低偏差値高校になっている。" },
        "銀河学院": { name_yomi: "ぎんががくいん", region: "中部", type: "私立", deviation: 55, best: "甲子園出場", last: "県大会ベスト16", info: "VRを取り入れたトレーニングを行う珍しい学校。よく野球youtuberに取り上げられている。野球部の成績もボチボチ" },
        "猫矢": { name_yomi: "ねこや", region: "中部", type: "公立", deviation: 49, best: "県大会2回戦", last: "初戦敗退", info: "人口1万人ほどの町にある小規模な公立校。チャンス応援時にはその校名にちなんで「猫ダンス」を披露する。" },
        "虎府島総合": { name_yomi: "こふとうそうごう", region: "西部", type: "公立", deviation: 47, best: "県大会ベスト16", last: "初戦敗退", info: "離島にある公立校。移動の際には巨額の資金が必要なので、本島へ遠征はめったにやらない。そのため、練習試合は基本的に組まれないが「虎府島スピリッツ」を胸にベスト8を目指す。島民からの信頼も厚く、試合時には島民の5割が駆け付けてくるらしい。" },
        "力全": { name_yomi: "りきぜん", region: "東部", type: "公立", deviation: 51, best: "県大会ベスト8", last: "初戦敗退", info: "校名通り、力こそ全てが校訓の公立校。練習ではウエイトメニューが6割を占めるが、私立の栄養状態にはかなわず、いつも強豪私立に競り負けてしまう。" },
        "帝王実業": { name_yomi: "ていおうじつぎょう", region: "中部", type: "私立", deviation: 55, best: "甲子園優勝", last: "初戦敗退", info: "古豪。半世紀前は5連覇をするほどの実力を持っていたが、それは過去の話。最近ではベスト8にも上がってこないので、復活を待ち望む声も多い。" },
        "小束": { name_yomi: "こづか", region: "西部", type: "私立", deviation: 56, best: "県大会ベスト4", last: "県大会ベスト16", info: "昔からある歴史のある私立校。野球部の成績も安定的に初戦は突破するものの上位にはいまいち食い込めないでいる。そろそろ覚醒に期待したい。" },
        "豊中學園": { name_yomi: "とよなかがくえん", region: "東部", type: "私立", deviation: 60, best: "県大会ベスト4", last: "県大会ベスト16", info: "ダークホース。強い高校にはめっぽう強く、二大公立やナムコグループ系列の高校には相性がいいが、普通の公立中堅校の試合では競り負けてしまう残念なチーム。実力は確かなので、ジンクスを解消したい。" },
        "須磨東": { name_yomi: "すまひがし", region: "東部", type: "私立", deviation: 61, best: "県大会ベスト8", last: "県大会ベスト16", info: "4年前はは準優勝したものの、ここ最近ではベスト16止まりが続く。" },
        "283学園B": { name_yomi: "つばさがくえんB", region: "西部", type: "私立", deviation: 59, best: "なし", last: "なし", info: "昨年の優勝により部員数が急激に増加した283学園。あまりにも試合に出れない人数が多いので理事長の配慮でbチームを作った。基本的に本部校でレギュラーになれなかったものたちの寄せ集めなので勝ち上がれないが、部員たちは打倒283学園を目指し頑張っている。県内からは同じ県内に同じ高校のチームの二つ目を作り大会に参加させるのは違反行為なのでは、という声が多く上がったが、県内はナムコグループが牛耳っているため、ごり押しで可決させた。" },
        "城場羅": { name_yomi: "じょうばら", region: "伊豆", type: "私立", deviation: 43, best: "県大会2回戦", last: "県大会2回戦", info: "去年共学になった。野球部も学校側が盛り上げようと、女子率を活かした大規模吹奏楽応援で球場の雰囲気を作る。" },
        "女子大共立": { name_yomi: "じょしだいきょうりつ", region: "中部", type: "私立", deviation: 63, best: "県大会2回戦", last: "県大会2回戦", info: "元女子高。野球部員よりもマネージャーの数の方が多い。" },
        "天下無双学園": { name_yomi: "てんかむそう", region: "東部", type: "私立", deviation: 55, best: "県準優勝", last: "県準優勝", info: "打撃こそ野球。がモットーの打撃型チーム。中堅校以下にはめっぽう強いが、甲子園出場レベルの相手にはめっぽう弱い。" },
        "横浜": { name_yomi: "よこはま", region: "東部", type: "公立", deviation: 62, best: "県大会ベスト16", last: "県大会2回戦", info: "公立ではあるものの、プロ野球選手のOBからの支援により設備は充実。その影響か、近年少しずつ力をつけている。" },
        "あかつき大付属": { name_yomi: "あかつきだいふぞく", region: "西部", type: "私立", deviation: 60, best: "甲子園準優勝", last: "県大会ベスト8", info: "甲子園を狙う野球二番手校。学校に集まってくるのは他校でセレクションに落ちたものの集まりである。" },
        "ときめき青春": { name_yomi: "ときめきせいしゅん", region: "中部", type: "私立", deviation: 57, best: "甲子園出場", last: "県大会2回戦", info: "中堅校。ユニークな名前とは裏腹に侮れない実力を持つ。" },
        "干鰯大付属": { name_yomi: "ひわしだいふぞく", region: "中部", type: "私立", deviation: 49, best: "県大会ベスト16", last: "県大会2回戦", info: "中堅校。野球部としての実績はないが、大学付属校のため、それなりのメンバーが集まるため、そこそこの戦力になる。" },
        "AOHARU学院": { name_yomi: "アオハルがくいん", region: "西部", type: "私立", deviation: 54, best: "甲子園ベスト8", last: "県大会2回戦", info: "中堅校。13年前には甲子園出場経験もある私立校。今では当時のエースだった青葉健司が監督となり、母校を再び聖地へと導こうとしている。" },
        "場須前第一": { name_yomi: "ばすまえだいいち", region: "東部", type: "公立", deviation: 53, best: "県大会2回戦", last: "初戦敗退", info: "野球部としての特色はないが、学校としてはその校名にちなんで、バスの運転手になるためのコースが設けられている。" },
        "北斗": { name_yomi: "ほくと", region: "東部", type: "公立", deviation: 58, best: "甲子園ベスト16", last: "初戦敗退", info: "30年前には甲子園経験もある。今では私立優勢になり、鳴りを潜めたが、もう一度輝いてほしい、と地元住民からの期待は高い。" },
        "赤霧大那覇": { name_yomi: "あかぎりだいなは", region: "西部", type: "私立", deviation: 51, best: "県大会ベスト8", last: "県大会2回戦", info: "中堅校。セイバーメトリクスを利用した効率的な野球で勝利を狙う。" },
        "極星学園": { name_yomi: "きょくせいがくえん", region: "西部", type: "私立", deviation: 49, best: "県大会ベスト4", last: "県大会2回戦", info: "中堅校。県内に蔓延るナムコグループに対抗して、極グループが設立した極星学園。5年前にはベスト4まで進出する快進撃を見せた侮れないチームである。" },
        "県立由暇": { name_yomi: "けんりつゆか", region: "中部", type: "公立", deviation: 48, best: "県大会初戦敗退", last: "初戦敗退", info: "普通の公立。公式戦で勝ったことがない。" },
        "足利": { name_yomi: "あしかが", region: "東部", type: "公立", deviation: 52, best: "県大会ベスト16", last: "初戦敗退", info: "県名物「足利山」のふもとに位置する高校。トレーニングでは足利山を利用したマラソンをする。" },
        "常翔学園": { name_yomi: "じょうしょうがくえん", region: "中部", type: "私立", deviation: 61, best: "甲子園出場", last: "県大会ベスト16", info: "中堅校。設立して19年と月日は浅いが、甲子園経験のある実力校。今年は、過去に帝王実業で甲子園連覇した際のチームの指揮を執っていた國村監督を招聘し、躍進が期待される。" },
        "音駒": { name_yomi: "ねこま", region: "東部", type: "公立", deviation: 62, best: "県大会ベスト16", last: "初戦敗退", info: "校名通り、吹奏楽部が売りの公立校。" },
        "七森": { name_yomi: "ななもり", region: "東部", type: "公立", deviation: 55, best: "県大会2回戦", last: "初戦敗退", info: "自由主義が校訓の公立校。常識にとらわれない発想は、野球のどう影響を及ぼすのだろうか。" },
        "珠湖": { name_yomi: "たまこ", region: "伊豆", type: "公立", deviation: 50, best: "県大会初戦敗退", last: "初戦敗退", info: "湖の近くに位置する小規模の学校。公式戦で勝ったことがない。" },
        "潮見": { name_yomi: "しおみ", region: "西部", type: "公立", deviation: 57, best: "県大会ベスト8", last: "初戦敗退", info: "たまに中盤まで勝ち進むが基本的にはトーナメント序盤での敗退が多い。" },
        "市立根戸": { name_yomi: "しりつねど", region: "伊豆", type: "公立", deviation: 46, best: "県大会ベスト16", last: "初戦敗退", info: "70年の歴史をもつ伝統校。野球部が盛り上がれば、地域も盛り上がるだろう。" },
        "福井": { name_yomi: "ふくい", region: "中部", type: "公立", deviation: 53, best: "県大会ベスト16", last: "初戦敗退", info: "バランスの良い公立校。毎年それなりのチームに仕上げてきているが、籤運が悪く、強豪私立に轢かれている。" },
        "春日井中央": { name_yomi: "かすがいちゅうおう", region: "中部", type: "公立", deviation: 59, best: "県大会ベスト4", last: "初戦敗退", info: "過去にはベスト4の経験もある公立校。" },
        "高槻南": { name_yomi: "たかつきみなみ", region: "西部", type: "公立", deviation: 56, best: "県大会2回戦", last: "初戦敗退", info: "今年学校を改築し、新校舎となったうえで迎える初めての夏、野球部が盛り上がれば学校としての人気も爆発的に伸びるのではないだろうか。" },
        "島田": { name_yomi: "しまだ", region: "中部", type: "公立", deviation: 53, best: "県大会2回戦", last: "初戦敗退", info: "大正8年からある古い学校だが、野球部の実績は乏しい。以前は部員数が足りない際には伊豆中央と連合チームを組んでいた。" },
        "伊豆中央": { name_yomi: "いずちゅうおう", region: "伊豆", type: "公立", deviation: 51, best: "県大会2回戦", last: "初戦敗退", info: "今年は久しぶりにメンバーがそろい、単独チームでの出場となった。以前は部員数が足りない際には島田と連合チームを組んでいた。" }
    };
    const DETAILED_TEAM_DATA = {
        "283学園": {
            summary: "夏の連覇の先に、聖地での勝利を目指す。昨年王者、守備の一体感と打線のつながりを強みに、試合ごとに成長。チームスローガンは『強』。個の技量に頼らず、一人ひとりの力を集めて戦う。",
            players: [
                { name: "姫川友紀", year: 3, position: "ピッチャー", desc: "投打の中心。MAX151kmの直球とスプリット、高校通算42本塁打の怪物。" },
                { name: "花海雄介", year: 3, position: "センター", desc: "走攻守三拍子揃ったリードオフマン。監督が「ものが違う」と絶賛。" },
                { name: "鈴木佐奈", year: 2, position: "ファースト", desc: "芯で捉える技術を持つ3番打者。守備でも存在感。" },
                { name: "十王星南", year: 3, position: "ショート", desc: "鉄壁の守備を誇る名手。チャンスメイクも得意な2番打者。" },
                { name: "浅倉享", year: 2, position: "レフト", desc: "2年生ながら5番に座るクラッチヒッター。ポテンシャルが高い。" },
                { name: "島村海斗", year: 3, position: "サード", desc: "強肩強打のパワーヒッター。勝負強い打撃が光る。" },
                { name: "有栖川悠覇", year: 3, position: "キャッチャー", desc: "大舞台に強い主軸。変化球打ちの技術はチームトップクラス。" },
                { name: "芹沢優吾", year: 2, position: "セカンド", desc: "小技と守備センスが光る二塁手。チャンスでの一打も。" },
                { name: "花海佑樹", year: 1, position: "ライト", desc: "1年生のスーパースター。兄・雄介との連携も抜群。既に通算13本塁打。" },
                { name: "天海晴彦", year: 2, position: "ピッチャー", desc: "チーム最速の直球を持つ。春はメンバー外の悔しさをバネに復調を目指す。" },
                { name: "松本晴康", year: 3, position: "ピッチャー", desc: "春の大会で完全試合を達成。伸び上がるストレートが武器。" }
            ]
        },
        "天下無双学園": {
            summary: "個々のレベルアップが結実し昨年は準優勝。個人成績の可視化と実力主義でチーム内の競争を活性化させ、初の甲子園を目指す。スローガンは『個々の能力重視』。",
            players: [
                { name: "沖田総司", year: 3, position: "ピッチャー", desc: "投打の大黒柱。MAX157kmの速球を持つ主砲。" },
                { name: "土方任三郎", year: 3, position: "キャッチャー", desc: "グラウンド上の監督。高いスローイング技術と高校通算28本塁打のパワーを持つ。" },
                { name: "宮本和佐", year: 3, position: "ファースト", desc: "力強い打撃と勝負強さが魅力の3番打者。" },
                { name: "柳生俊昌", year: 2, position: "セカンド", desc: "バッティングセンスに優れる2年生。落ち着いたプレーが光る。" },
                { name: "近藤春樹", year: 3, position: "サード", desc: "ガッツあふれるプレーでチームを引っ張る5番打者。高校通算46本塁打。" },
                { name: "坂本俊樹", year: 3, position: "ショート", desc: "走攻守三拍子揃った抜群の身体能力を持つショート。" },
                { name: "岡田克也", year: 3, position: "ライト", desc: "高校通算71本塁打を誇る絶対的な4番。恵まれた体格からの強打が武器。" },
                { name: "森晴継", year: 2, position: "センター", desc: "50m6秒フラットの俊足。攻守にわたり抜群の勝負強さを見せる。" },
                { name: "上泉誠", year: 3, position: "レフト", desc: "バランスと勝負強い打撃が武器。逆転劇のきっかけを作る。" },
                { name: "拝拓也", year: 3, position: "ピッチャー", desc: "巧みな投球術と強い精神力を持つ控え投手。MAX155km。" },
                { name: "疋田文也", year: 2, position: "ピッチャー", desc: "クレバーさと強気を兼ね備えた2年生投手。昨夏も登板経験あり。" }
            ]
        },
        "雷門南": {
            summary: "昨年ベスト4。選手の長所を活かす野球で、磨き上げた守備力とタイプの違う3年生投手3人の継投を武器に、2005年以来の夏の聖地を目指す。",
            players: [
                { name: "豪円秀一", year: 3, position: "ピッチャー", desc: "最速158kmの直球と縦スライダーで打者を打ち取る絶対的エース。" },
                { name: "遠藤憲作", year: 3, position: "キャッチャー", desc: "冷静なリードで多彩な投手陣を引っ張る扇の要。3番打者としても活躍。" },
                { name: "風山英二郎", year: 3, position: "ファースト", desc: "190cmの長身を生かした守備と長打力が魅力。" },
                { name: "飯田慎二", year: 3, position: "セカンド", desc: "小柄ながら攻守に堅実なプレーでチームに貢献。" },
                { name: "一ノ瀬拓郎", year: 3, position: "サード", desc: "チーム一の打球の速さを誇る2番打者。" },
                { name: "土門海斗", year: 3, position: "ショート", desc: "ミスの少ない堅実な守備で試合のリズムを作る内野の要。" },
                { name: "外岡竜吾", year: 3, position: "レフト", desc: "監督も絶大な信頼を寄せる大砲。気持ちの強さも魅力。" },
                { name: "花丸一郎", year: 3, position: "センター", desc: "サイクルヒット達成経験もあるリードオフマン。ミート力が格段にアップ。" },
                { name: "久松鉄平", year: 2, position: "ライト", desc: "力強いスイングから放たれる長打が魅力の2年生。" },
                { name: "木頭優斗", year: 3, position: "ピッチャー", desc: "キレのある縦スライダーと内角への直球が魅力の右腕。" },
                { name: "松野裕介", year: 2, position: "ピッチャー", desc: "MAX144kmのストレートとカットボールが武器の2年生。奪三振能力が高い。" }
            ]
        },
        "代矢東": {
            summary: "投打の大黒柱を中心にダイナミックなベースボールを展開。攻めの姿勢を貫き、1999年以来の聖地を見据える伝統校。どこからでも得点できる打線が強み。",
            players: [
                { name: "渋谷卓", year: 3, position: "ピッチャー", desc: "常時150km超の速球を投げる本格派エース。" },
                { name: "片野坂晴人", year: 3, position: "キャッチャー", desc: "小柄ながら強肩強打の司令塔。盗塁阻止率は随一。" },
                { name: "郷野将暉", year: 3, position: "ファースト", desc: "高校通算63本塁打のプロ注目スラッガー。得点圏での勝負強さが光る。" },
                { name: "片倉郁弥", year: 3, position: "セカンド", desc: "俊足と広い守備範囲が武器の機動力内野手。" },
                { name: "島津成哉", year: 3, position: "サード", desc: "反応速度と強肩が武器の守備の要。広角に打ち分ける打撃も。" },
                { name: "藤原元輝", year: 3, position: "ショート", desc: "軽快なフットワークが光る守備職人。つなぎ役もこなす。" },
                { name: "倉科哲史", year: 3, position: "レフト", desc: "小柄ながら高い身体能力を持つ。クリーンアップの前を打つ。" },
                { name: "滝川文隆", year: 3, position: "センター", desc: "抜群の走力でセンターラインを統率するリードオフマン。" },
                { name: "川又良太", year: 3, position: "ライト", desc: "安定した打率を誇る右打者。正確な返球も魅力。" },
                { name: "六反田良弥", year: 3, position: "ピッチャー", desc: "最速152kmの剛腕。リリーフも先発もこなす万能型。" },
                { name: "鳥羽晴康", year: 3, position: "ピッチャー", desc: "左腕から多彩な変化球を投げるクローザー的存在。" }
            ]
        },
        "青道": {
            summary: "昨年ベスト8。選手の長所を活かした攻撃力と堅守を武器に雪辱を期す。タイプの異なる3人の投手による継投が強み。",
            players: [
                { name: "沢村栄玲", year: 2, position: "ピッチャー", desc: "最速140kmの直球と多彩な変化球で三振を奪う次世代エース左腕。" },
                { name: "降谷暁", year: 3, position: "ピッチャー", desc: "長身から投げ下ろすスライダーとシュートが武器の大型右腕。" },
                { name: "御幸一也", year: 3, position: "キャッチャー", desc: "攻守にわたる高い野球センスを誇るプロ注目の司令塔。" },
                { name: "前園裕太", year: 2, position: "一塁手／外野手", desc: "高い打撃技術と強肩を持つ大型野手。" },
                { name: "小湊夏樹", year: 3, position: "二塁手", desc: "堅実な守備と巧みなバットコントロールが光る。" },
                { name: "金村真也", year: 3, position: "三塁手", desc: "打球反応が速く、強肩が武器。中距離ヒッター。" },
                { name: "倉田実", year: 2, position: "ショート", desc: "俊敏な動きと華麗な守備が魅力の内野の要。" },
                { name: "結城大介", year: 3, position: "レフト", desc: "長打力を武器に快音を響かせる強打者。" },
                { name: "西城光希", year: 3, position: "センター", desc: "強肩と確実な捕球で外野を統率する守備職人。" },
                { name: "白瀬浩司", year: 3, position: "ライト", desc: "打撃センスが光る左打者。冷静な状況判断が持ち味。" }
            ]
        },
        "武蔵野第一": {
            summary: "雪辱を期す知性派軍団。絶対的エース榛名を擁し、データを駆使した緻密な野球で昨夏の悔しさを晴らす。チームスローガンは『知は力なり』。",
            players: [
                { name: "榛名 元希", year: 3, position: "ピッチャー", desc: "最速140km後半の直球と高速スライダーで三振の山を築く絶対的エース。打っても5番。" },
                { name: "秋丸協平", year: 3, position: "キャッチャー", desc: "冷静沈着なリードでエース榛名を支える扇の要。" },
                { name: "大川 公彦", year: 3, position: "ファースト", desc: "チーム不動の4番。一振りで試合の流れを変えるパワーが魅力。" },
                { name: "福原 恭介", year: 3, position: "ショート", desc: "卓越したバットコントロールと選球眼を持つ1番打者。守備も堅実。" },
                { name: "町田誠", year: 3, position: "センター", desc: "走攻守三拍子揃ったアベレージヒッター。3番を担う。" }
            ]
        },
        "稲城実業": {
            summary: "王座奪還へ、揺るぎなき『王国』のプライド。昨年の雪辱に燃える絶対王者。投打にタレントを揃え、最強左腕・成宮を軸に再び全国の頂点を目指す。スローガンは『常勝』。",
            players: [
                { name: "成宮 鳴", year: 3, position: "ピッチャー", desc: "「キング」の異名を持つ世代最強左腕。MAX150km/hの直球と魔球チェンジアップを操る。" },
                { name: "神谷 カルロス 俊樹", year: 3, position: "センター", desc: "50m5秒台の俊足を誇る「チーター」。攻守に規格外の身体能力を見せる。" },
                { name: "白河 勝之", year: 3, position: "ショート", desc: "卓越した野球センスと華麗な守備が光る内野の司令塔。" },
                { name: "多田野 樹", year: 2, position: "キャッチャー", desc: "「キング」成宮の女房役を射止めた2年生捕手。冷静なリードが持ち味。" },
                { name: "山岡 陸", year: 3, position: "サード", desc: "稲実の新たな4番打者。勝負強いクラッチヒッター。高校通算61本。" }
            ]
        },
        "あかつき大付属": {
            summary: "あかつき史上最強の『黄金世代』。投打の柱・猪狩兄弟を擁し、個の力で世代の頂点を証明する。セレクション落ちの雑草軍団が狙うは完全優勝。スローガンは『実力主義』。",
            players: [
                { name: "猪狩 守", year: 3, position: "ピッチャー", desc: "「黄金世代」を率いるキャプテンにして絶対的エース。「ライジングキャノン」と呼ばれる剛速球が武器。" },
                { name: "猪狩 進", year: 2, position: "キャッチャー", desc: "兄・守とバッテリーを組む天才捕手。「球界の頭脳」と称されるリードと俊足が武器。" },
                { name: "三本松 一", year: 3, position: "ファースト", desc: "不動の4番。高校生離れしたパワーを誇る規格外の長距離砲。" },
                { name: "七井将暉", year: 3, position: "レフト", desc: "三本松と双璧をなす長距離砲。広角に打ち分ける技術と「バズーカ」強肩も。" },
                { name: "矢部 翔雄", year: 3, position: "センター", desc: "俊足が武器の外野手。意外な勝負強さも見せる。" }
            ]
        }
    };


    const INITIAL_TEAM_POOL = Object.keys(TEAM_DATA);

    // --- Utility & State Functions ---
    function shuffleArray(array) {
        const newArray = [...array];
        for (let i = newArray.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
        }
        return newArray;
    }
    
    function saveState() {
        try {
            localStorage.setItem('tournamentState', JSON.stringify(tournamentState));
        } catch (e) {
            console.error("進行状況の保存に失敗しました:", e);
            showAlert("進行状況の保存に失敗しました。ブラウザのストレージ容量が不足している可能性があります。");
        }
    }
    
    function uint8ArrayToBase64(bytes) {
        let binary = '';
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
    }

    // --- Custom Alert/Confirm ---
    function showAlert(message) {
        alert(message);
    }

    function showConfirm(message) {
        return new Promise((resolve) => {
            const confirmOk = document.getElementById('confirm-ok');
            const confirmCancel = document.getElementById('confirm-cancel');
            document.getElementById('confirm-modal-text').textContent = message;
            confirmModal.classList.remove('hidden');

            const onOk = () => {
                confirmModal.classList.add('hidden');
                cleanup();
                resolve(true);
            };

            const onCancel = () => {
                confirmModal.classList.add('hidden');
                cleanup();
                resolve(false);
            };
            
            const cleanup = () => {
                confirmOk.removeEventListener('click', onOk);
                confirmCancel.removeEventListener('click', onCancel);
            };

            confirmOk.addEventListener('click', onOk);
            confirmCancel.addEventListener('click', onCancel);
        });
    }

    function getRankFromHistoryString(historyString) {
        if (historyString.includes('優勝')) return 1;
        if (historyString.includes('準優勝')) return 2;
        if (historyString.includes('ベスト4')) return 4;
        if (historyString.includes('ベスト8')) return 8;
        if (historyString.includes('ベスト16')) return 16;
        if (historyString.includes('3回戦')) return 16;
        if (historyString.includes('2回戦')) return 32;
        if (historyString.includes('初戦敗退')) return 64;
        return 64; // Default for "なし" or other cases
    }
    
    // --- NEW AUTUMN TOURNAMENT FUNCTIONS ---

    /**
     * Sets up and runs the Autumn Regional Qualifiers, creating mini-tournaments for each region.
     */
    function setupAutumnRegionalQualifiers() {
        tournamentState.autumnPhase = 'regional';
        tournamentState.autumnBrackets = {
            '東部': { tournaments: [], reps: [], totalTeams: 0 },
            '中部': { tournaments: [], reps: [], totalTeams: 0 },
            '西部': { tournaments: [], reps: [], totalTeams: 0 },
            '伊豆': { tournaments: [], reps: [], totalTeams: 0 }
        };

        const teamsByRegion = { '東部': [], '中部': [], '西部': [], '伊豆': [] };
        INITIAL_TEAM_POOL.forEach(teamName => {
            const region = TEAM_DATA[teamName]?.region;
            if (region && teamsByRegion[region]) {
                teamsByRegion[region].push(teamName);
            }
        });

        const repCounts = { '東部': 5, '中部': 5, '西部': 5, '伊豆': 1 };

        for (const region in teamsByRegion) {
            let regionalTeams = shuffleArray(teamsByRegion[region]);
            tournamentState.autumnBrackets[region].totalTeams = regionalTeams.length;
            const numTournaments = repCounts[region];

            for (let i = 0; i < numTournaments; i++) {
                const podTeams = regionalTeams.splice(0, 4);
                const tournamentId = `T${i + 1}`;
                const matches = {};
                
                // Pad with byes if not a full 4-team pod
                while(podTeams.length < 4) podTeams.push(null);

                // Create R1 matches
                const r1m1_id = `${region}-${tournamentId}-R1-M1`;
                const r1m2_id = `${region}-${tournamentId}-R1-M2`;
                matches[r1m1_id] = { team1: podTeams[0], team2: podTeams[1], winner: null, score1: '', score2: '', summary: '' };
                matches[r1m2_id] = { team1: podTeams[2], team2: podTeams[3], winner: null, score1: '', score2: '', summary: '' };

                // Handle automatic byes in R1
                if (!podTeams[1]) matches[r1m1_id].winner = podTeams[0];
                if (!podTeams[3]) matches[r1m2_id].winner = podTeams[2];

                // Create R2 (final) match
                const r2m1_id = `${region}-${tournamentId}-R2-M1`;
                matches[r2m1_id] = { 
                    team1: matches[r1m1_id].winner, 
                    team2: matches[r1m2_id].winner, 
                    winner: null, score1: '', score2: '', summary: '' 
                };
                
                // Check if final is already decided by byes
                if (matches[r2m1_id].team1 && matches[r2m1_id].team2 === null) {
                    matches[r2m1_id].winner = matches[r2m1_id].team1;
                } else if (matches[r2m1_id].team1 === null && matches[r2m1_id].team2) {
                    matches[r2m1_id].winner = matches[r2m1_id].team2;
                }
                
                // If pod final winner is decided by byes, add to reps
                if (matches[r2m1_id].winner) {
                     tournamentState.autumnBrackets[region].reps.push(matches[r2m1_id].winner);
                }

                tournamentState.autumnBrackets[region].tournaments.push({
                    id: tournamentId,
                    matches: matches
                });
            }
        }

        renderAutumnRegionalPhase();
        saveState();
    }

    /**
     * Renders the UI for the Autumn Regional Qualifiers phase.
     */
    function renderAutumnRegionalPhase() {
        mainBracketContainer.classList.add('hidden');
        autumnControls.classList.add('hidden');
        autumnPhaseContainer.classList.remove('hidden');
        newsContainer.innerHTML = '<p class="text-gray-500 text-center">地区予選進行中です。</p>';
        bbsCommentsContainer.innerHTML = '<p class="text-gray-500 text-center">地区予選進行中です。</p>';

        const { autumnBrackets } = tournamentState;
        let html = `<h2 class="text-2xl font-bold text-gray-800 mb-6 text-center">秋季大会 地区予選</h2>`;
        html += '<div class="space-y-8">';

        for (const region in autumnBrackets) {
            const regionData = autumnBrackets[region];
            html += `
                <div class="p-4 border-2 rounded-lg shadow-md">
                    <h3 class="text-xl font-semibold mb-4 border-b pb-2 text-purple-700">${region}地区 (${regionData.reps.length} / ${regionData.tournaments.length} 代表決定)</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6">
                        ${regionData.tournaments.map((pod, index) => `
                            <div class="p-3 border rounded-lg bg-gray-50">
                                <h4 class="font-bold text-center mb-2">予選ブロック ${index + 1}</h4>
                                ${createMiniBracketHTML(pod, region)}
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }
        html += '</div>';
        autumnPhaseContainer.innerHTML = html;
        checkAllRegionalsComplete();
    }

    /**
     * Creates the HTML for a single 4-team mini-tournament bracket.
     */
    function createMiniBracketHTML(podData, region) {
        const r1m1_id = `${region}-${podData.id}-R1-M1`;
        const r1m2_id = `${region}-${podData.id}-R1-M2`;
        const r2m1_id = `${region}-${podData.id}-R2-M1`;

        const r1m1 = podData.matches[r1m1_id];
        const r1m2 = podData.matches[r1m2_id];
        
        // Update R2 teams based on R1 results
        podData.matches[r2m1_id].team1 = r1m1.winner;
        podData.matches[r2m1_id].team2 = r1m2.winner;
        const r2m1 = podData.matches[r2m1_id];

        return `
            <div class="flex items-center justify-center space-x-4">
                <div class="space-y-4">
                    ${createMatchHTML(r1m1_id, r1m1.team1, r1m1.team2, r1m1, [])}
                    ${createMatchHTML(r1m2_id, r1m2.team1, r1m2.team2, r1m2, [])}
                </div>
                <div class="flex items-center">
                     ${createMatchHTML(r2m1_id, r2m1.team1, r2m1.team2, r2m1, [])}
                </div>
            </div>
        `;
    }

    /**
     * Checks if all regional qualifiers are complete and shows the proceed button.
     */
    function checkAllRegionalsComplete() {
        const { autumnBrackets } = tournamentState;
        if (!autumnBrackets) return;

        let totalReps = 0;
        let totalPossibleReps = 0;
        for (const region in autumnBrackets) {
            totalReps += autumnBrackets[region].reps.length;
            totalPossibleReps += autumnBrackets[region].tournaments.length;
        }

        if (totalReps === totalPossibleReps && totalPossibleReps > 0) {
            autumnControls.classList.remove('hidden');
            startMainTournamentBtn.classList.remove('hidden');
            startPlayoffBtn.classList.add('hidden'); // Ensure playoff button is hidden
        } else {
            autumnControls.classList.add('hidden');
            startMainTournamentBtn.classList.add('hidden');
        }
    }

    /**
     * Sets up the final 16-team Autumn Prefectural Tournament using regional winners.
     */
    async function setupAutumnMainTournament() {
        tournamentState.autumnPhase = 'main';
        autumnPhaseContainer.classList.add('hidden');
        autumnControls.classList.add('hidden');
        mainBracketContainer.classList.remove('hidden');

        const allReps = [];
        const seeds = [];
        const regionOrder = ['東部', '西部', '中部', '伊豆']; // For seeding placement

        regionOrder.forEach(region => {
            const regionData = tournamentState.autumnBrackets[region];
            if (regionData && regionData.reps.length > 0) {
                // Shuffle reps within the region before adding, except for the first one (seed)
                const regionalSeed = regionData.reps[0];
                const otherReps = shuffleArray(regionData.reps.slice(1));
                allReps.push(regionalSeed, ...otherReps);
                seeds.push(regionalSeed); 
            }
        });
        
        const nonSeeds = allReps.filter(t => !seeds.includes(t));
        const shuffledNonSeeds = shuffleArray(nonSeeds);

        let teams = Array(16).fill(null);
        const seedPositions = [0, 8, 12, 4]; // Distribute seeds across the bracket
        seeds.forEach((seed, i) => {
            if(seedPositions[i] !== undefined) teams[seedPositions[i]] = seed;
        });

        let nonSeedIndex = 0;
        for (let i = 0; i < 16; i++) {
            if (teams[i] === null) {
                teams[i] = shuffledNonSeeds[nonSeedIndex++];
            }
        }

        tournamentState.teams = teams.filter(Boolean);
        tournamentState.matches = {}; // Reset main matches
        tournamentState.seeds = seeds;
        tournamentState.is16team = true;

        const round1Setup = tournamentState.teams.reduce((acc, team, i) => {
            if (i % 2 === 0) acc.push({ team1: team, team2: null });
            else acc[acc.length - 1].team2 = team;
            return acc;
        }, []);

        round1Setup.forEach((match, index) => {
            const side = index < 4 ? 'L' : 'R';
            const matchNum = index < 4 ? index + 1 : index - 3;
            const matchId = `${side}-R1-M${matchNum}`;
            tournamentState.matches[matchId] = { team1: match.team1, team2: match.team2, winner: null, score1: '', score2: '', details: null, summary: '' };
        });

        saveState();
        renderTournament(tournamentState);
        
        const currentTournamentName = "秋季県大会本戦";
        newsContainer.innerHTML = `<div class="loader">AI記者が${currentTournamentName}の展望記事を執筆中...</div>`;
        bbsCommentsContainer.innerHTML = `<div class="loader">AIが組み合わせを分析中...</div>`;

        const [previewArticle, bracketComments] = await Promise.all([
            generateNewsArticle(null, null, null, 'preview', null, null),
            generateBracketReactionComments(tournamentState)
        ]);

        if (previewArticle) tournamentState.news.unshift(previewArticle);
        if (bracketComments && bracketComments.length > 0) tournamentState.bbsComments.push(...bracketComments);
        
        renderNews(tournamentState.news);
        renderBbsComments(tournamentState.bbsComments);
        saveState();
    }

    // --- Tournament Logic ---
    async function createNewTournament(isNext = false, nextTournamentType = 'summer') {
        const tournamentNameMap = { summer: '夏季大会', autumn: '秋季大会', spring: '春季大会' };
        setupEl.classList.add('hidden');
        tournamentDisplayEl.classList.remove('hidden');

if (!isNext) { // 新規トーナメント開始時のみ選手を初期化
            initializeFullRoster();
        }

        // === Autumn Tournament: Start Regional Qualifiers ===
        if (nextTournamentType === 'autumn') {
            tournamentState.currentTournament = 'autumn';
            if (isNext && tournamentState.currentTournament !== 'summer') {
                tournamentState.tournamentYear++;
            } else if (!isNext) {
                tournamentState.tournamentYear = 1;
            }

            // Initialize state for the phased tournament
            tournamentState.teams = [];
            tournamentState.matches = {};
            tournamentState.news = [];
            tournamentState.seeds = [];
            tournamentState.bbsComments = [];
            tournamentState.daiyaBbsComments = [];
            tournamentState.namcoNews = null;
            tournamentState.autumnBrackets = {};
            tournamentState.is16team = false;

            // Start the regional qualifier phase
            setupAutumnRegionalQualifiers();
            return;
        }
        
        // === Summer/Spring/Initial Tournament Logic ===
        else {
            autumnPhaseContainer.classList.add('hidden');
            autumnControls.classList.add('hidden');
            mainBracketContainer.classList.remove('hidden');

            tournamentState.is16team = false;
            let teams;
            let seeds = [];

            if (isNext) {
                tournamentState.currentTournament = nextTournamentType;
                 if(nextTournamentType === 'summer') tournamentState.tournamentYear++;
                const lastTournamentTeams = Object.keys(tournamentState.teamRecords)
                    .map(teamName => ({ name: teamName, ...tournamentState.teamRecords[teamName] }))
                    .sort((a, b) => a.lastFinish - b.lastFinish);
                seeds = lastTournamentTeams.slice(0, 8).map(t => t.name);
            } else { // Initial setup
                tournamentState.tournamentYear = 1;
                tournamentState.currentTournament = 'summer';
                tournamentState.teamRecords = {};
                const historicalRanks = INITIAL_TEAM_POOL.map(teamName => ({
                    name: teamName,
                    rank: getRankFromHistoryString(TEAM_DATA[teamName].last)
                }));
                historicalRanks.sort((a, b) => a.rank - b.rank);
                seeds = historicalRanks.slice(0, 8).map(t => t.name);
                INITIAL_TEAM_POOL.forEach(t => {
                    const historicalRank = historicalRanks.find(hr => hr.name === t);
                    tournamentState.teamRecords[t] = { wins: 0, losses: 0, best: null, lastFinish: historicalRank ? historicalRank.rank : 64, previousRank: null };
                });
            }

            const nonSeeds = INITIAL_TEAM_POOL.filter(t => !seeds.includes(t));
            const shuffledNonSeeds = shuffleArray(nonSeeds);
            teams = Array(64).fill(null);
            const seedPositionsTemplate = [0, 32, 16, 48, 8, 40, 24, 56];
            const seedPositions = seedPositionsTemplate.slice(0, seeds.length);
            const seedPlacements = {};
            seeds.forEach((seed, i) => { seedPlacements[seedPositions[i]] = seed; });
            let nonSeedIndex = 0;
            for (let i = 0; i < 64; i++) {
                teams[i] = seedPlacements[i] ? seedPlacements[i] : shuffledNonSeeds[nonSeedIndex++];
            }

            tournamentState.teams = teams;
            tournamentState.matches = {};
            tournamentState.news = [];
            tournamentState.seeds = seeds;
            tournamentState.bbsComments = [];
            tournamentState.daiyaBbsComments = [];
            tournamentState.namcoNews = null;
            tournamentState.autumnPhase = null;

            const round1Setup = teams.reduce((acc, team, i) => {
                if (i % 2 === 0) acc.push({ team1: team, team2: null });
                else acc[acc.length - 1].team2 = team;
                return acc;
            }, []);

            round1Setup.forEach((match, index) => {
                const side = index < 16 ? 'L' : 'R';
                const matchNum = index < 16 ? index + 1 : index - 15;
                const matchId = `${side}-R1-M${matchNum}`;
                tournamentState.matches[matchId] = { team1: match.team1, team2: match.team2, winner: null, score1: '', score2: '', details: null, summary: '' };
            });

            saveState();
            renderTournament(tournamentState);
            
            const currentTournamentName = tournamentNameMap[tournamentState.currentTournament];
            newsContainer.innerHTML = `<div class="loader">AI記者が${currentTournamentName}の展望記事を執筆中...</div>`;
            bbsCommentsContainer.innerHTML = `<div class="loader">AIが組み合わせを分析中...</div>`;
            namcoNewsSection.classList.remove('hidden');
            namcoNewsContent.innerHTML = `<div class="loader">ナムコグループからのお知らせを確認中...</div>`;

            const [previewArticle, bracketComments, namcoNews] = await Promise.all([
                generateNewsArticle(null, null, null, 'preview', null, null),
                generateBracketReactionComments(tournamentState),
                generateNamcoNews(tournamentState, 'bracket')
            ]);

            if (previewArticle) tournamentState.news.unshift(previewArticle);
            if (bracketComments && bracketComments.length > 0) tournamentState.bbsComments.push(...bracketComments);
            if (namcoNews) tournamentState.namcoNews = namcoNews;

            renderNews(tournamentState.news);
            renderBbsComments(tournamentState.bbsComments);
            renderNamcoNews(tournamentState.namcoNews);
            saveState();
        }
    }

    // --- Rendering Functions ---
    function renderTournament(data) {
        const tournamentNameMap = {
            summer: '夏季大会',
            autumn: '秋季大会',
            spring: '春季大会'
        };
        const isAutumnMain = data.currentTournament === 'autumn' && data.autumnPhase === 'main';
        const tournamentNameString = isAutumnMain ? '秋季大会 県大会本戦' : (tournamentNameMap[data.currentTournament] || '大会');
        tournamentYearDisplay.textContent = `${data.tournamentYear}年度 ${tournamentNameString}`;

        renderMainBracket(data);
        renderRegionMap(data);
        renderNews(data.news || []);
        renderBbsComments(data.bbsComments || []);
        renderDaiyaBbsComments(data.daiyaBbsComments || []);
        renderNamcoNews(data.namcoNews);
        checkTournamentProgress();
    }

    function renderMainBracket(data) {
        if (!data.teams || data.teams.length === 0) {
             mainBracketContainer.innerHTML = '';
             return;
        };

        const { matches, teams, seeds } = data;
        const numTeams = teams.length;

        const bracketContentWrapper = document.createElement('div');
        bracketContentWrapper.className = 'flex flex-row';

        const leftBracketEl = document.createElement('div');
        leftBracketEl.className = 'bracket-half left';

        const rightBracketEl = document.createElement('div');
        rightBracketEl.className = 'bracket-half right';
        
        const finalRound = Math.log2(numTeams);
        const semiFinalRound = finalRound - 1;
        
        const leftChampion = data.matches[`L-R${semiFinalRound}-M1`]?.winner ?? null;
        const rightChampion = data.matches[`R-R${semiFinalRound}-M1`]?.winner ?? null;
        
        const finalMatch = data.matches['F-R1-M1'] || {};
        const finalTeam1 = finalMatch.team1 ?? leftChampion;
        const finalTeam2 = finalMatch.team2 ?? rightChampion;

        const finalEl = document.createElement('div');
        finalEl.className = 'bracket-final';
        finalEl.innerHTML = `<div class="final-title">決勝</div><div class="final-matchup" data-match-id="F-R1-M1">${createMatchHTML('F-R1-M1', finalTeam1, finalTeam2, finalMatch, seeds)}</div><div class="winner-box" id="tournament-winner">${finalMatch.winner ? `🏆 ${finalMatch.winner} 🏆` : '🏆'}</div>`;

        const round1Setup = teams.reduce((acc, team, i) => {
            if (i % 2 === 0) acc.push({ team1: team, team2: null });
            else acc[acc.length - 1].team2 = team;
            return acc;
        }, []);
        
        const leftHalfSetup = round1Setup.slice(0, round1Setup.length / 2);
        const rightHalfSetup = round1Setup.slice(round1Setup.length / 2);

        generateHalf(leftBracketEl, leftHalfSetup, 'L', matches, seeds);
        generateHalf(rightBracketEl, rightHalfSetup, 'R', matches, seeds);

        mainBracketContainer.innerHTML = '';
        bracketContentWrapper.append(leftBracketEl, finalEl, rightBracketEl);
        mainBracketContainer.appendChild(bracketContentWrapper);

        if (finalMatch.winner) {
            nextTournamentBtn.classList.remove('hidden');
        } else {
            nextTournamentBtn.classList.add('hidden');
        }
    }

    function renderRegionMap(data) {
        const regionMapSection = document.getElementById('region-map-section');
        if (!data.matches || Object.keys(data.matches).length === 0) {
            regionMapSection.classList.add('hidden');
            return;
        }
        regionMapSection.classList.remove('hidden');

        const container = document.getElementById('region-map-container');
        const teamsByRegion = { '東部': [], '中部': [], '西部': [], '伊豆': [] };
        INITIAL_TEAM_POOL.forEach(teamName => {
            const region = TEAM_DATA[teamName]?.region;
            if (region && teamsByRegion[region]) {
                teamsByRegion[region].push(teamName);
            }
        });

        const eliminatedTeams = new Set(
            Object.values(data.matches)
                .filter(match => match.winner)
                .map(match => match.team1 === match.winner ? match.team2 : match.team1)
        );

        let html = '<div class="region-map">';
        for (const region in teamsByRegion) {
            const teams = teamsByRegion[region];
            const survivingCount = teams.filter(team => !eliminatedTeams.has(team)).length;

            html += `
            <div class="region-column">
                <div class="region-header">
                    <h3 class="region-title">${region}地区</h3>
                    <p class="region-stats">${survivingCount} / ${teams.length} チーム生存</p>
                </div>
                <ul class="region-team-list">
                    ${teams.map(team => `
                        <li class="region-team ${eliminatedTeams.has(team) ? 'team-eliminated' : 'team-surviving'}">
                            ${team}
                        </li>
                    `).join('')}
                </ul>
            </div>
            `;
        }
        html += '</div>';
        container.innerHTML = html;
    }

    function generateHalf(containerEl, setup, side, allMatches, seeds) {
        containerEl.innerHTML = '';
        const numMatchesInFirstRound = setup.length;
        const numTeamsOnSide = numMatchesInFirstRound * 2;
        const numRounds = Math.log2(numTeamsOnSide);

        const roundNameMap = tournamentState.is16team
            ? { 1: "1回戦", 2: "準々決勝", 3: "準決勝" }
            : { 1: "1回戦", 2: "2回戦", 3: "3回戦", 4: "準々決勝", 5: "準決勝" };

        const roundElements = [];
        for (let i = 0; i < numRounds; i++) {
            const roundEl = document.createElement('div');
            roundEl.className = 'round';
            if (i > 0) roundEl.classList.add('subsequent-round');

            const roundTitle = document.createElement('h3');
            roundTitle.className = 'text-center font-bold mb-2';
            roundTitle.textContent = roundNameMap[i + 1] || `${i + 1}回戦`;
            roundEl.appendChild(roundTitle);

            containerEl.appendChild(roundEl);
            roundElements.push(roundEl);
        }

        setup.forEach((matchSetup, index) => {
            const matchId = `${side}-R1-M${index + 1}`;
            let dbMatch = allMatches[matchId] || {};
            roundElements[0].insertAdjacentHTML('beforeend', createMatchHTML(matchId, matchSetup.team1, matchSetup.team2, dbMatch, seeds));
        });

        for (let r = 2; r <= numRounds; r++) {
            const numMatchesInRound = numMatchesInFirstRound / Math.pow(2, r - 1);
            for (let m = 1; m <= numMatchesInRound; m++) {
                const matchId = `${side}-R${r}-M${m}`;
                const prevMatch1Id = `${side}-R${r - 1}-M${(m * 2) - 1}`;
                const prevMatch2Id = `${side}-R${r - 1}-M${m * 2}`;
                const team1 = allMatches[prevMatch1Id]?.winner || null;
                const team2 = allMatches[prevMatch2Id]?.winner || null;
                const dbMatch = allMatches[matchId] || {};
                roundElements[r - 1].insertAdjacentHTML('beforeend', createMatchHTML(matchId, team1, team2, dbMatch, seeds));
            }
        }
    }    
    
    function calculateRank(teamName, state) {
        if (!teamName) return ''; 

        const teamData = TEAM_DATA[teamName];
        let score = 0;

        score += teamData.deviation;

        if (teamData.best.includes('優勝')) score += 25;
        else if (teamData.best.includes('準優勝')) score += 20;
        else if (teamData.best.includes('ベスト4')) score += 15;
        else if (teamData.best.includes('ベスト8')) score += 10;
        else if (teamData.best.includes('出場')) score += 10;
        else if (teamData.best.includes('ベスト16')) score += 5;

        if (teamData.popularity) score += 5;

        if (state.teamRecords && state.teamRecords[teamName]) {
            const lastFinish = state.teamRecords[teamName].lastFinish;
            const rankMultiplier = 3.0; 
            if (lastFinish === 1) score += 30 * rankMultiplier; 
            else if (lastFinish === 2) score += 25 * rankMultiplier;
            else if (lastFinish <= 4) score += 20 * rankMultiplier;
            else if (lastFinish <= 8) score += 15 * rankMultiplier;
            else if (lastFinish <= 16) score += 5 * rankMultiplier;
            else if (lastFinish >= 64) score -= 5 * rankMultiplier;
        }
        
        if (score >= 85) return 'A';
        if (score >= 70) return 'B';
        if (score >= 55) return 'C';
        if (score >= 40) return 'D';
        return 'E';
    }


    function createMatchHTML(matchId, team1, team2, dbMatch, seeds = []) {
        const t1Empty = !team1;
        const t2Empty = !team2;
        const rank1 = calculateRank(team1, tournamentState);
        const rank2 = calculateRank(team2, tournamentState);
        const rankColor = (rank) => {
            switch(rank) {
                case 'A': return 'rank-A';
                case 'B': return 'rank-B';
                case 'C': return 'rank-C';
                case 'D': return 'rank-D';
                case 'E': return 'rank-E';
                default: return '';
            }
        };
        
        const isMainBracketMatch = matchId.includes('-R');
        const roundStr = isMainBracketMatch ? matchId.split('-')[1] : '';
        const showDetailsButton = !t1Empty && !t2Empty && (roundStr === 'R5' || matchId.startsWith('F-'));
        const isSeed1 = seeds.includes(team1);
        const isSeed2 = seeds.includes(team2);

        const content = `
            <div class="team-slot ${t1Empty ? 'empty' : ''} ${dbMatch.winner === team1 && !t1Empty ? 'winner' : ''} ${dbMatch.winner && dbMatch.winner !== team1 && dbMatch.winner !== null ? 'loser' : ''}" data-team-name="${team1 || ''}">
                <span class="team-name ${isSeed1 ? 'seed' : ''}" title="${team1 || ''}">
                    ${team1 ? `<span class="rank ${rankColor(rank1)}">[${rank1}]</span>` : ''}
                    ${isSeed1 ? 'S ' : ''}${team1 || '---'}
                </span>
                <input type="text" class="score-input" value="${dbMatch.score1 ?? ''}" data-team-pos="1">
                <button class="win-btn">▶</button>
            </div>
            <div class="team-slot ${t2Empty ? 'empty' : ''} ${dbMatch.winner === team2 && !t2Empty ? 'winner' : ''} ${dbMatch.winner && dbMatch.winner !== team2 && dbMatch.winner !== null ? 'loser' : ''}" data-team-name="${team2 || ''}">
                <span class="team-name ${isSeed2 ? 'seed' : ''}" title="${team2 || ''}">
                    ${team2 ? `<span class="rank ${rankColor(rank2)}">[${rank2}]</span>` : ''}
                    ${isSeed2 ? 'S ' : ''}${team2 || '---'}
                </span>
                <input type="text" class="score-input" value="${dbMatch.score2 ?? ''}" data-team-pos="2">
                <button class="win-btn">▶</button>
            </div>
            <div class="match-summary-container ${!t1Empty && !t2Empty ? '' : 'hidden'}">
                <textarea class="match-summary-input w-full text-xs p-1 mt-1 border rounded" data-match-id="${matchId}" placeholder="試合の決め手（任意）">${dbMatch.summary || ''}</textarea>
            </div>
            `;
        
        const footer = showDetailsButton ? `<div class="matchup-footer"><button class="details-btn" data-match-id="${matchId}">詳細入力</button></div>` : '';

        return `<div class="matchup" data-match-id="${matchId}">${content}${footer}</div>`;
    }
    
    function renderNews(news) {
        if (!news || news.length === 0) {
            newsContainer.innerHTML = `<p class="text-gray-500 text-center">まだニュースはありません。</p>`;
            return;
        }
        newsContainer.innerHTML = '';
        news.slice().reverse().forEach((article, index) => {
            const articleEl = document.createElement('div');
            if (article.error) {
                articleEl.className = 'article-error';
                articleEl.innerHTML = `
                    <span>${article.title}</span>
                    <button class="retry-btn" data-error-id="${article.errorId}">再生成</button>
                `;
            } else {
                const originalIndex = news.length - 1 - index;
                articleEl.className = 'bg-white p-4 rounded-lg shadow';
                articleEl.innerHTML = `
                    <div class="flex justify-between items-start">
                        <div>
                            <h3 class="font-bold text-lg text-blue-600">${article.title}</h3>
                            <p class="text-xs text-gray-400 mt-1">${new Date(article.timestamp).toLocaleDateString('ja-JP')}</p>
                        </div>
                        <div>
                            <button class="text-sm bg-gray-200 px-3 py-1 rounded hover:bg-gray-300 news-article-btn" data-index="${originalIndex}">本文</button>
                            ${article.isNewspaper ? `<button class="text-sm bg-red-100 text-red-700 px-3 py-1 rounded hover:bg-red-200 ml-2 newspaper-view-btn" data-index="${originalIndex}">新聞を読む</button>` : ''}                            
                        </div>
                    </div>
                `;
            }
            newsContainer.appendChild(articleEl);
        });
    }
    
    /**
     * Renders comment threads recursively.
     */
    function renderCommentThread(comment, container, bbsType) {
        const threadContainer = document.createElement('div');
        if (container.id === `replies-to-${comment.id}` || (container.id.includes('bbs-comments') && container.children.length > 0)) {
            threadContainer.className = 'ml-4 border-l-2 pl-4 mt-2';
        } else {
            threadContainer.className = 'mt-2';
        }

        const personalityClass = comment.personality === 'あなた' ? 'text-blue-600 font-bold' : 'text-gray-600';
        const commentEl = document.createElement('div');
        commentEl.className = 'bbs-comment';
        commentEl.innerHTML = `
            <div class="flex justify-between items-center">
                <p class="font-semibold ${personalityClass} text-sm">${comment.personality || '名無しさん'}</p>
                <button class="reply-btn text-xs text-blue-500 hover:underline" data-comment-id="${comment.id}" data-bbs-type="${bbsType}">返信する</button>
            </div>
            <p class="text-gray-800 my-1 whitespace-pre-wrap">${comment.text}</p>
            <p class="text-xs text-gray-400 text-right">${new Date(comment.timestamp).toLocaleString('ja-JP')}</p>
            <div id="reply-form-container-${comment.id}" class="hidden mt-2">
                <form class="reply-form" data-comment-id="${comment.id}" data-bbs-type="${bbsType}">
                    <textarea class="w-full p-2 border rounded text-sm" placeholder="返信を入力..." required></textarea>
                    <button type="submit" class="mt-1 bg-blue-500 text-white px-3 py-1 text-xs rounded hover:bg-blue-600">送信</button>
                </form>
            </div>
        `;
        threadContainer.appendChild(commentEl);

        const repliesContainer = document.createElement('div');
        repliesContainer.id = `replies-to-${comment.id}`;
        threadContainer.appendChild(repliesContainer);

        container.appendChild(threadContainer);

        if (comment.replies && comment.replies.length > 0) {
            comment.replies.slice().reverse().forEach(reply => {
                renderCommentThread(reply, repliesContainer, bbsType);
            });
        }
    }

    function renderBbsComments(comments) {
        if (!comments || comments.length === 0) {
            bbsCommentsContainer.innerHTML = `<p class="text-gray-500 text-center">まだ反応はありません。</p>`;
            return;
        }
        bbsCommentsContainer.innerHTML = '';
        comments.slice().reverse().forEach(comment => {
            renderCommentThread(comment, bbsCommentsContainer, 'general');
        });
    }

    function renderDaiyaBbsComments(comments) {
        if (!comments || comments.length === 0) {
            daiyaBbsCommentsContainer.innerHTML = `<p class="text-gray-500 text-center">まだ反応はありません。</p>`;
            return;
        }
        daiyaBbsCommentsContainer.innerHTML = '';
        comments.slice().reverse().forEach(comment => {
            renderCommentThread(comment, daiyaBbsCommentsContainer, 'daiya');
        });
    }

    function renderNamcoNews(news) {
        if (!news) {
            namcoNewsSection.classList.add('hidden');
            return;
        }
        namcoNewsSection.classList.remove('hidden');
        namcoNewsContent.innerHTML = '';
        const newsItem = document.createElement('div');
        newsItem.className = 'namco-news-item p-2 hover:bg-orange-50 rounded';
        newsItem.innerHTML = `<p class="font-semibold text-gray-700">${news.title}<span class="namco-news-tag">野球部</span></p>`;
        newsItem.addEventListener('click', () => {
            document.getElementById('modal-title').textContent = news.title;
            document.getElementById('modal-body').textContent = news.body;
            document.getElementById('modal-meta').innerHTML = `<p>${new Date(news.timestamp).toLocaleDateString('ja-JP')}</p><p class="font-bold text-gray-500">野球部</p>`;
            newsModal.classList.remove('hidden');
            newsModal.classList.add('flex');
        });
        namcoNewsContent.appendChild(newsItem);
    }

    // --- AI Reporter Logic ---
    function parseJsonFromText(text) {
        try {
            const cleanedText = text.replace(/```json/g, '').replace(/```/g, '').trim();
            const jsonMatch = cleanedText.match(/\{[\s\S]*\}|\[[\s\S]*\]/);
            if (jsonMatch) {
                return JSON.parse(jsonMatch[0]);
            }
        } catch (e) {
            console.error("Failed to parse JSON from text:", text, e);
        }
        return null;
    }

    async function fetchWithRetry(payload, maxRetries = 3) {
        const functionUrl = '/.netlify/functions/generateApiContent';
        let lastError;

        for (let i = 0; i < maxRetries; i++) {
            try {
                const response = await fetch(functionUrl, {
                    method: 'POST',
                    body: JSON.stringify(payload)
                });

                if (response.ok) {
                    return response;
                }
                
                if (response.status >= 400 && response.status < 500 && response.status !== 429) {
                    console.error(`Client Error: ${response.status}. Not retrying.`);
                    const errorData = await response.json();
                    throw new Error(`API Error: ${errorData.error}`);
                }

                lastError = new Error(`API Error: ${response.status}`);
                const delay = Math.pow(2, i) * 1000;
                console.log(`API call failed. Retrying in ${delay}ms...`);
                await new Promise(resolve => setTimeout(resolve, delay));

            } catch (error) {
                lastError = error;
                const delay = Math.pow(2, i) * 1000;
                console.error(`Network error: ${error.message}. Retrying in ${delay}ms...`);
                if (i < maxRetries - 1) {
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }
        throw lastError;
    }

    function getRankDescription(rank) {
        switch(rank) {
            case 'A': return '名門校';
            case 'B': return '強豪校';
            case 'C': return '中堅校';
            case 'D': return '発展途上のチーム';
            case 'E': return '挑戦者';
            default: return '';
        }
    }
    
    function createNewspaperHtml(articleData, matchData) {
        const { winnerName, loserName, dbMatch, matchId } = matchData;
        const [side, roundStr] = matchId.split('-');
        const roundNum = side === 'F' ? 6 : parseInt(roundStr.slice(1));

        const isLateRound = roundNum >= 4;
        const containerClass = isLateRound ? 'newspaper-late' : 'newspaper-early';
        const winnerScore = dbMatch.team1 === winnerName ? dbMatch.score1 : dbMatch.score2;
        const loserScore = dbMatch.team1 === winnerName ? dbMatch.score2 : dbMatch.score1;

        return `
            <div class="newspaper-container ${containerClass}">
                <div class="newspaper-header">
                    <h2 class="newspaper-title">熱闘高校野球</h2>
                    <p class="newspaper-date">${new Date(articleData.timestamp).toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric' })}</p>
                </div>
                <div class="newspaper-content">
                    <h1 class="newspaper-main-headline">${winnerName}</h1>
                    <div class="newspaper-body-content">
                        <h2 class="newspaper-sub-headline">${articleData.title}</h2>
                        ${isLateRound ? '<div class="newspaper-image-placeholder">[試合の様子の写真]</div>' : ''}
                        <p class="newspaper-text">${articleData.body.replace(/\\n/g, '\n')}</p>
                        <div class="newspaper-score-box">
                            <h3>最終スコア</h3>
                            <p class="score">${winnerName} ${winnerScore} - ${loserScore} ${loserName}</p>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    async function generateNewsArticle(winnerName, loserName, dbMatch, matchId, nextOpponentInfo, matchSummary) {
        const tournamentNameMap = { summer: '夏季大会', autumn: '秋季大会', spring: '春季大会' };
        const currentTournamentName = tournamentNameMap[tournamentState.currentTournament] || '大会';

        if (matchId === 'preview') {
            let prompt;
            const { tournamentYear, seeds, teams } = tournamentState;

            if (tournamentState.is16team) {
                const reps = tournamentState.autumnBrackets;
                const repText = Object.entries(reps).map(([region, data]) => 
                    `- ${region} (${data.reps.length}校): ${data.reps.join(', ')}`
                ).join('\n');
                
                const matchups = [];
                for(let i=0; i<teams.length; i+=2) {
                    matchups.push(`- ${teams[i]} vs ${teams[i+1]}`);
                }

                prompt = `
あなたは、情熱的で経験豊富な高校野球専門のAI記者です。
間もなく開幕する「${tournamentYear}年度 秋季大会 県大会本戦」の展望記事を作成してください。
この大会は、各地区予選を勝ち抜いた精鋭16校によって争われます。

### 県大会出場校一覧
${repText}

### 県大会1回戦の組み合わせ
${matchups.join('\n')}

### 県大会シード校
${seeds.join(', ') || 'なし'}

### 執筆指示
- 上記の情報を基に、県大会全体の展望をまとめてください。
- 地区予選を勝ち抜いてきた各校の紹介や、注目の対戦カードについて触れ、読者の期待感を煽るような情熱的なトーンでお願いします。

### 出力形式
以下のJSON形式で、タイトルと本文を生成してください。
{"title": "記事のタイトル", "body": "記事の本文（改行は\\nを使用）"}
`;
            } else { // Summer/Spring
                const blockA_teams = teams.slice(0, 16);
                const blockB_teams = teams.slice(16, 32);
                const blockC_teams = teams.slice(32, 48);
                const blockD_teams = teams.slice(48, 64);
                const findPromisingSchools = (teamList) => teamList.filter(team => seeds.includes(team) || DETAILED_TEAM_DATA[team] || TEAM_DATA[team].popularity || TEAM_DATA[team].best.includes('甲子園'));
                
                const blockAnalysis = `
- Aブロック: ${findPromisingSchools(blockA_teams).join(', ') || '特になし'}
- Bブロック: ${findPromisingSchools(blockB_teams).join(', ') || '特になし'}
- Cブロック: ${findPromisingSchools(blockC_teams).join(', ') || '特になし'}
- Dブロック: ${findPromisingSchools(blockD_teams).join(', ') || '特になし'}
                `.trim();

                const regionPower = { '東部': [], '中部': [], '西部': [], '伊豆': [] };
                [...new Set([...findPromisingSchools(blockA_teams), ...findPromisingSchools(blockB_teams), ...findPromisingSchools(blockC_teams), ...findPromisingSchools(blockD_teams)])].forEach(team => {
                    const region = TEAM_DATA[team]?.region;
                    if (region) regionPower[region].push(team);
                });
                const regionAnalysis = Object.entries(regionPower)
                    .map(([region, schools]) => `- **${region}地区**: 有力校 ${schools.length}校 (${schools.join(', ') || 'なし'})`)
                    .join('\n');

                prompt = `
あなたは、情熱的で経験豊富な高校野球専門のAI記者です。
間もなく開幕する「${tournamentYear}年度 ${currentTournamentName}」の展望記事を作成してください。

### 大会全体情報
- 大会名: ${tournamentYear}年度 ${currentTournamentName}
- シード校: ${seeds.join(', ') || 'なし'}

### 各ブロックの有力校
${blockAnalysis}

### 今大会の地区別勢力図
${regionAnalysis}

### 執筆指示
- 上記の情報を基に、大会全体の展望をまとめてください。
- **「死のブロックとなったAブロックには西部地区の強豪が集中している」**といった、ブロック分けと地区勢力図を組み合わせた、より深い分析をしてください。
- 読者の期待感を煽るような、情熱的なトーンでお願いします。

### 出力形式
以下のJSON形式で、タイトルと本文を生成してください。
{"title": "記事のタイトル", "body": "記事の本文（改行は\\nを使用）"}
`;
            }

            try {
                const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
                const result = await response.json();
                if (result.candidates?.[0]?.content?.parts?.[0]) {
                    const rawText = result.candidates[0].content.parts[0].text;
                    const article = parseJsonFromText(rawText);
                    if (article) return { ...article, timestamp: Date.now(), newspaperHtml: null };
                }
                throw new Error("AI preview article response format error.");
            } catch (error) {
                console.error("AI preview article generation failed:", error);
                return { title: "展望記事生成エラー", body: "AI記者との通信に失敗しました。", timestamp: Date.now(), error: true, errorId: `preview-${Date.now()}`, newspaperHtml: null };
            }
        }
        
        // Match result article
        const winnerData = TEAM_DATA[winnerName];
        const loserData = TEAM_DATA[loserName];
        const winnerScore = dbMatch.team1 === winnerName ? dbMatch.score1 : dbMatch.score2;
        const loserScore = dbMatch.team1 === winnerName ? dbMatch.score2 : dbMatch.score1;
        const winnerRankDesc = getRankDescription(calculateRank(winnerName, tournamentState));
        const loserRankDesc = getRankDescription(calculateRank(loserName, tournamentState));
        const isCivilWar = (winnerName === '283学園' && loserName === '283学園B') || (winnerName === '283学園B' && loserName === '283学園');

        const [side, roundStr] = matchId.split('-');
        const roundNum = side === 'F' ? (tournamentState.is16team ? 4 : 6) : parseInt(roundStr.slice(1));
        let roundAchievement = '';

        if (tournamentState.is16team) {
            switch (roundNum) {
                case 1: roundAchievement = '初戦突破(ベスト8進出)'; break;
                case 2: roundAchievement = '準々決勝突破(ベスト4進出)'; break;
                case 3: roundAchievement = '準決勝突破(決勝進出)'; break;
                case 4: roundAchievement = '優勝！'; break;
            }
        } else {
            switch (roundNum) {
                case 1: roundAchievement = '初戦突破'; break;
                case 2: roundAchievement = '2回戦突破'; break;
                case 3: roundAchievement = '3回戦突破(ベスト16進出)'; break;
                case 4: roundAchievement = '準々決勝突破(ベスト8進出)'; break;
                case 5: roundAchievement = '準決勝突破(決勝進出)'; break;
                case 6: roundAchievement = (currentTournamentName === '夏季大会') ? '甲子園出場決定！' : '優勝！'; break;
            }
        }

        let civilWarInstruction = isCivilWar ? `- **この試合は「283ダービー」です。この「身内対決」を記事の最大のテーマとしてください。**` : '';

        const prompt = `
あなたは、情熱的で経験豊富な高校野球専門のAI記者です。
以下の試合結果とチーム情報に基づき、読者の心を掴むようなドラマチックなニュース記事を生成してください。

### 試合情報
- 大会: ${tournamentState.tournamentYear}年度 ${currentTournamentName}
- ラウンド達成記録: ${roundAchievement}
- 勝利チーム: ${winnerName} (${winnerRankDesc})
- 敗北チーム: ${loserName} (${loserRankDesc})
- スコア: ${winnerName} ${winnerScore} - ${loserScore} ${loserName}
- 試合のハイライト（ユーザー入力）: ${matchSummary || 'なし'}

### 執筆のポイント
${civilWarInstruction}
- 記事の中で「${winnerName}が${roundAchievement}を決めた」という事実を必ず含めてください。
- 両チームのランクも考慮し、番狂わせか順当な結果かを記事に含めてください。
- 記事のトーンは、ドラマチックかつ客観的に。

### 出力形式
以下のJSON形式で、タイトルと本文を生成してください。
{"title": "記事のタイトル", "body": "記事の本文（改行は\\nを使用）"}
`;

        try {
            const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
                const rawText = result.candidates[0].content.parts[0].text;
                const article = parseJsonFromText(rawText);
                if (article) {
                    const newspaperHtml = createNewspaperHtml(article, { winnerName, loserName, dbMatch, matchId });
                    return { ...article, timestamp: Date.now(), newspaperHtml };
                }
            }
            throw new Error("AIからの応答が予期した形式ではありません。");
        } catch (error) {
            console.error("AI記事の生成に失敗しました:", error);
            return {
                title: "記事生成エラー",
                body: "AI記者との通信に失敗しました。時間をおいて再度お試しください。",
                timestamp: Date.now(),
                error: true,
                errorId: matchId,
                context: { winnerName, loserName, dbMatch, matchId, nextOpponentInfo, matchSummary },
                newspaperHtml: null
            };
        }
    }    
    
    /**
     * Finds a comment by its ID in a nested comment structure.
     */
    function findCommentById(comments, id) {
        for (const comment of comments) {
            if (comment.id === id) return comment;
            if (comment.replies && comment.replies.length > 0) {
                const found = findCommentById(comment.replies, id);
                if (found) return found;
            }
        }
        return null;
    }

    /**
     * Formats the conversation history for the AI prompt.
     */
    function formatConversationHistory(comments, targetId) {
        let history = [];
        function findPath(currentComments, currentPath) {
            for(const comment of currentComments) {
                const newPath = [...currentPath, comment];
                if(comment.id === targetId) {
                    history = newPath;
                    return true;
                }
                if(comment.replies && findPath(comment.replies, newPath)) {
                    return true;
                }
            }
            return false;
        }
        findPath(comments, []);
        return history.map(c => `${c.personality}:「${c.text}」`).join('\n');
    }

    function checkBest8Decided() {
        if (tournamentState.is16team) { // No Best 8 summary for 16-team tournament
            generateSummaryBtn.classList.add('hidden');
            return;
        }
        const round3MatchIds = ['L-R3-M1', 'L-R3-M2', 'L-R3-M3', 'L-R3-M4', 'R-R3-M1', 'R-R3-M2', 'R-R3-M3', 'R-R3-M4'];
        const completedMatches = round3MatchIds.filter(id => tournamentState.matches[id] && tournamentState.matches[id].winner).length;

        if (completedMatches === 8) {
            const summaryArticleExists = tournamentState.news.some(article => article.errorId && article.errorId.startsWith('summary-'));
            const quarterFinalsStarted = Object.keys(tournamentState.matches).some(id => id.includes('R4') && tournamentState.matches[id].winner);

            if (!summaryArticleExists && !quarterFinalsStarted) {
                generateSummaryBtn.classList.remove('hidden');
            }
        } else {
            generateSummaryBtn.classList.add('hidden');
        }
    }

    async function generateBest8PreviewArticle() {
        const quarterFinalists = [];
        const quarterFinalMatchups = [];
        const quarterFinalIds = ['L-R4-M1', 'L-R4-M2', 'R-R4-M1', 'R-R4-M2'];

        quarterFinalIds.forEach(id => {
            const match = tournamentState.matches[id];
            if (match && match.team1 && match.team2) {
                quarterFinalists.push(match.team1, match.team2);
                quarterFinalMatchups.push(`${match.team1} vs ${match.team2}`);
            }
        });

        if (quarterFinalists.length !== 8) return null;

        const best8Paths = [...new Set(quarterFinalists)].map(team => {
            const round3Match = Object.entries(tournamentState.matches).find(([id, match]) =>
                id.includes('-R3-') && match.winner === team
            );
            const matchIdForPath = round3Match ? round3Match[0] : null;

            if (matchIdForPath) {
                const path = getTournamentPath(team, matchIdForPath);
                return `- **${team}**: ${path}`;
            }
            return `- **${team}**: (勝ち上がり履歴不明)`;
        }).join('\n');

        const prompt = `
あなたは、情熱的な高校野球専門のAI記者です。
${tournamentState.tournamentYear}年度大会の3回戦が終了し、ベスト8に進出する8校が決定しました。
以下の情報に基づき、これから始まる準々決勝への期待感を煽るような展望記事を生成してください。

### ベスト8進出チームと勝ち上がり
${best8Paths}

### 準々決勝の組み合わせ
- ${quarterFinalMatchups.join('\n- ')}

### 執筆指示
- まず、ベスト8に勝ち上がったチームの顔ぶれについて触れてください。**各チームがどの格付け（名門校、強豪校など）の高校を、どのような点差で倒してきたかという「勝ち上がり履歴」にも言及し**、トーナメントを総括します。
- 次に、決定した準々決勝の4つの対戦カードそれぞれについて、見どころや注目選手、勝敗の鍵を予想してください。
- 記事のタイトルは「激闘のベスト8！準々決勝の組み合わせが決定！」のような、読者の興味を引くものにしてください。
- これから始まる戦いへのワクワク感を高めるような、熱意のある文章で締めくくってください。

### 出力形式
以下のJSON形式で、タイトルと本文を生成してください。
{"title": "記事のタイトル", "body": "記事の本文（改行は\\nを使用）"}
`;
        try {
            const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
                const rawText = result.candidates[0].content.parts[0].text;
                const article = parseJsonFromText(rawText);
                if (article) return { ...article, timestamp: Date.now(), newspaperHtml: null, errorId: `summary-${Date.now()}` };
            }
            throw new Error("AI summary article response format error.");
        } catch (error) {
            console.error("AI summary article generation failed:", error);
            return { title: "展望記事生成エラー", body: "AI記者との通信に失敗しました。", timestamp: Date.now(), error: true, errorId: `summary-${Date.now()}`, newspaperHtml: null };
        }
    }

    async function generateSportsNewspaper(roundNumber) {
        const numTeams = tournamentState.is16team ? 16 : 64;
        const finalRound = Math.log2(numTeams);

        const roundNameMap = {
            [finalRound]: '決勝',
            [finalRound-1]: '準決勝',
            [finalRound-2]: '準々決勝',
            [finalRound-3]: '3回戦'
        };

        const roundName = roundNameMap[roundNumber];
        if (!roundName) return null;

        const matchIdsInRound = Object.keys(tournamentState.matches).filter(id => 
            (id.includes(`-R${roundNumber}-`)) || (roundNumber === finalRound && id.includes('F-R1-'))
        );
        const results = matchIdsInRound.map(id => tournamentState.matches[id]);

        const resultsText = results.map(match => {
            const winnerRank = getRankDescription(calculateRank(match.winner, tournamentState));
            const loser = match.team1 === match.winner ? match.team2 : match.team1;
            const loserRank = getRankDescription(calculateRank(loser, tournamentState));
            return `${winnerRank}・${match.winner}が${loserRank}・${loser}に ${match.score1}-${match.score2} で勝利。`;
        }).join('\n');

        const prompt = `
あなたは、読者の購買意欲を掻き立てるのが得意な、日本のスポーツ新聞の編集長です。
現在、高校野球の${tournamentState.tournamentYear}年度大会が進行中です。${roundName}の全試合が終了しました。
以下の試合結果を基に、最も衝撃的でドラマチックな出来事を一つ選び出し、それに対応する新聞の一面を飾るテキストと、そのシーンを撮影するための画像生成プロンプトを作成してください。

### ${roundName} 全試合結果
${resultsText}

### あなたが作成するテキストとプロンプト
以下の5つの要素を、JSON形式で出力してください。
1.  **mainHeadline**: 最も重要な結果を伝える、短く、衝撃的で、扇情的な大見出し。（例：「怪物散る！」「王者、盤石の決勝へ」）
2.  **subHeadline**: mainHeadlineを補足する、少し詳しい小見出し。
3.  **photoCaption**: その日のハイライトシーンを切り取った架空の写真に対する、情景が目に浮かぶようなキャプション。（例：「あと一歩及ばず、マウンドに崩れ落ちる〇〇高校のエース△△」）
4.  **otherResults**: その他の注目すべき結果を2つ、簡潔にまとめたもの。
5.  **imagePrompt**: mainHeadlineとphotoCaptionの情景を表現する、英語の画像生成プロンプト。リアルな写真ではなく、感動的なアニメや漫画のスタイルで生成すること。（例：'A high school baseball pitcher collapsing on the mound in defeat, dramatic anime style, cinematic lighting'）

### 出力形式
{"mainHeadline": "...", "subHeadline": "...", "photoCaption": "...", "otherResults": ["...", "..."], "imagePrompt": "..."}
`;
        try {
            const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
                const rawText = result.candidates[0].content.parts[0].text;
                const newspaperData = parseJsonFromText(rawText);
                if (newspaperData) return newspaperData;
            }
            throw new Error("AI newspaper response format error.");
        } catch (error) {
            console.error("AI newspaper generation failed:", error);
            return null;
        }
    }

    async function handleRoundCompletion(roundNumber) {
        const numTeams = tournamentState.is16team ? 16 : 64;
        const finalRound = Math.log2(numTeams);
        const significantRounds = [finalRound, finalRound-1, finalRound-2, finalRound-3].filter(r => r > 0);
        if (!significantRounds.includes(roundNumber)) return;

        const alreadyExists = tournamentState.news.some(n => n.roundNumber === roundNumber && n.isNewspaper);
        if (alreadyExists) return;

        const newspaperData = await generateSportsNewspaper(roundNumber);
        if (newspaperData) {
            if (newspaperData.imagePrompt) {
                try {
                    newspaperData.imageUrl = `https://via.placeholder.com/400x200.png?text=Image+for:${newspaperData.mainHeadline.replace(/\s/g, '+')}`;
                } catch (e) {
                    console.error("Image generation failed:", e);
                }
            }
            const roundNameMap = { 3: '3回戦', 4: '準々決勝', 5: '準決勝', 6: '決勝' };
            const roundName = tournamentState.is16team ? {1: '1回戦', 2: '準々決勝', 3: '準決勝', 4: '決勝'}[roundNumber] : roundNameMap[roundNumber];

            tournamentState.news.push({
                title: `【熱闘新聞】${roundName}特集号が発行されました！`,
                body: newspaperData.subHeadline,
                timestamp: Date.now(),
                isNewspaper: true,
                roundNumber: roundNumber,
                newspaperData: newspaperData
            });
            renderNews(tournamentState.news);
            saveState();
        }
    }

    function renderNewspaperModal(newspaperData) {
        const { mainHeadline, subHeadline, photoCaption, otherResults, imageUrl } = newspaperData;
        
        const imageHtml = imageUrl 
            ? `<img src="${imageUrl}" alt="${photoCaption}" class="w-full h-auto my-4 border">` 
            : `<div class="newspaper-image-placeholder"><p class="text-sm p-4">${photoCaption}</p></div>`;

        newspaperModalBody.innerHTML = `
            <div class="newspaper-container newspaper-late">
                <div class="newspaper-header">
                    <h2 class="newspaper-title">熱闘スポーツ</h2>
                    <p class="newspaper-date">${new Date().toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric' })}</p>
                </div>
                <div class="newspaper-content">
                    <h1 class="newspaper-main-headline">${mainHeadline}</h1>
                    <div class="newspaper-body-content">
                        <h2 class="newspaper-sub-headline">${subHeadline}</h2>
                        ${imageHtml}
                        <div class="newspaper-score-box">
                            <h3>その他の主な結果</h3>
                            ${otherResults.map(r => `<p>${r}</p>`).join('')}
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    function getTournamentPath(teamName, startingMatchId) {
        if (!teamName) return "（不明）";
        const path = [];
        const [startSide, startRoundStr] = startingMatchId.split('-');
        let startRoundNum = parseInt(startRoundStr.slice(1));

        const matchData = tournamentState.matches[startingMatchId];
        if (matchData && matchData.winner !== teamName) {
            startRoundNum--;
        }

        for (let r = 1; r <= startRoundNum; r++) {
            const matchInRound = Object.entries(tournamentState.matches).find(([id, match]) =>
                id.startsWith(`${startSide}-R${r}-`) &&
                match.winner === teamName &&
                (match.team1 === teamName || match.team2 === teamName)
            );

            if (matchInRound) {
                const match = matchInRound[1];
                const opponent = match.team1 === teamName ? match.team2 : match.team1;
                const opponentRank = calculateRank(opponent, tournamentState);
                const opponentRankDesc = getRankDescription(opponentRank); 
                const winnerScore = match.team1 === teamName ? match.score1 : match.score2;
                const loserScore = match.team1 === teamName ? match.score2 : match.score1;
                path.push(`${r}回戦で${opponentRankDesc}・${opponent}に ${winnerScore}-${loserScore} で勝利`);
            }
        }
        return path.length > 0 ? path.join(' → ') : '（今大会初戦）';
    }

    function getTournamentStatusSummary() {
        const matches = tournamentState.matches;
        const allMatchIds = Object.keys(matches);

        const getMatchResultString = (id) => {
            const match = matches[id];
            if (match && match.winner) {
                const loser = match.team1 === match.winner ? match.team2 : match.team1;
                const winnerScore = match.team1 === match.winner ? match.score1 : match.score2;
                const loserScore = match.team1 === match.winner ? match.score2 : match.score1;
                const winnerRankDesc = getRankDescription(calculateRank(match.winner, tournamentState));
                const loserRankDesc = getRankDescription(calculateRank(loser, tournamentState));
                return `${winnerRankDesc}・${match.winner}が${loserRankDesc}・${loser}に ${winnerScore}-${loserScore} で勝利`;
            }
            return null;
        };

        const finalResult = getMatchResultString('F-R1-M1');
        if (finalResult) return `決勝戦は${finalResult}し、${matches['F-R1-M1'].winner}が優勝しました。`;
        if (matches['F-R1-M1']?.team1 && matches['F-R1-M1']?.team2) return `決勝戦の組み合わせは ${matches['F-R1-M1'].team1} vs ${matches['F-R1-M1'].team2} です。`;

        const numRounds = Math.log2(tournamentState.teams.length) -1;
        for (let r = numRounds; r >= 1; r--) {
            const roundIds = allMatchIds.filter(id => id.includes(`-R${r}-`));
            const roundResults = roundIds.map(getMatchResultString).filter(Boolean);
            const roundUpcoming = roundIds.map(id => (matches[id] && matches[id].team1 && matches[id].team2 && !matches[id].winner) ? `${matches[id].team1} vs ${matches[id].team2}` : null).filter(Boolean);
            
            if (roundResults.length > 0 || roundUpcoming.length > 0) {
                let roundName = `${r}回戦`;
                if(r === numRounds) roundName = "準決勝";
                if(r === numRounds-1) roundName = "準々決勝";

                let summary = `現在、${roundName}が進行中です。\n`;
                if (roundResults.length > 0) summary += `- 終了した試合の結果: ${roundResults.join(' / ')}\n`;
                if (roundUpcoming.length > 0) summary += `- これからの対戦: ${roundUpcoming.join(' / ')}\n`;
                return summary;
            }
        }
        return '現在、1回戦が進行中です。';
    }

    function getNextOpponentInfoForPrompt(teamName) {
        let latestMatchId = null;
        let maxRound = 0;

        for (const [id, match] of Object.entries(tournamentState.matches)) {
            if (match.team1 === teamName || match.team2 === teamName) {
                const roundNum = id.startsWith('F-') ? (tournamentState.is16team ? 4 : 6) : parseInt(id.split('-')[1].slice(1));
                if (roundNum > maxRound) {
                    maxRound = roundNum;
                    latestMatchId = id;
                }
            }
        }
        
        if (!latestMatchId) return "（まだ試合なし）";

        const latestMatch = tournamentState.matches[latestMatchId];
        if (latestMatch.winner !== teamName) return "（この試合で敗退）";
        
        const finalRound = Math.log2(tournamentState.teams.length);
        if (maxRound === finalRound) return "（優勝）";

        const [side, roundStr, matchStr] = latestMatchId.split('-');
        const roundNum = parseInt(roundStr.slice(1));
        const matchNum = parseInt(matchStr.slice(1));

        if (roundNum === finalRound -1) {
            const otherSide = side === 'L' ? 'R' : 'L';
            const otherSemiFinalId = `${otherSide}-R${roundNum}-M1`;
            const otherSemiFinal = tournamentState.matches[otherSemiFinalId];
            if (otherSemiFinal && otherSemiFinal.winner) {
                return `決勝の相手は${otherSemiFinal.winner}です。`;
            } else if (otherSemiFinal) {
                return `決勝の相手は${otherSide}ブロックの準決勝の勝者です。`;
            }
        }

        const nextRoundNum = roundNum + 1;
        const nextMatchNum = Math.ceil(matchNum / 2);
        const nextMatchId = `${side}-R${nextRoundNum}-M${nextMatchNum}`;
        
        const nextMatch = tournamentState.matches[nextMatchId];
        const otherOpponent = (matchNum % 2 !== 0) ? nextMatch?.team2 : nextMatch?.team1;
        if(otherOpponent) return `次の対戦相手は${otherOpponent}です。`;

        const otherFeederMatchNum = (matchNum % 2 !== 0) ? matchNum + 1 : matchNum - 1;
        const otherFeederMatchId = `${side}-R${roundNum}-M${otherFeederMatchNum}`;
        const otherMatch = tournamentState.matches[otherFeederMatchId];
        if(otherMatch && otherMatch.team1 && otherMatch.team2) {
            return `次の対戦相手は、${otherMatch.team1} vs ${otherMatch.team2} の勝者です。`;
        }
        return "（次の対戦相手は未定）";
    }

    async function generateBbsReply(parentCommentId, userReplyText, bbsType, aiPersona, context, teamHistoryData, teamPathData, teamNextOpponentData) {
        const commentSource = bbsType === 'general' ? tournamentState.bbsComments : tournamentState.daiyaBbsComments;
        const parentComment = findCommentById(commentSource, parentCommentId);
        if (!parentComment) return null;

        const userReplyObject = {
            id: 'temp_user_reply',
            personality: 'あなた',
            text: userReplyText,
            replies: []
        };

        parentComment.replies.push(userReplyObject);
        const conversationHistory = formatConversationHistory(commentSource, 'temp_user_reply');
        parentComment.replies.pop();

        const teamHistoryPromptPart = Object.keys(teamHistoryData).length > 0
            ? `### 関連チームの公式プロフィール（過去の歴史・前評判）\n${Object.entries(teamHistoryData).map(([name, data]) => `- **${name}**: 最高成績「${data.best}」、情報「${data.info}」`).join('\n')}`
            : '';
        
        const teamPathPromptPart = Object.keys(teamPathData).length > 0
            ? `### 今大会の勝ち上がり状況（現在の事実）\n${Object.entries(teamPathData).map(([name, path]) => `- **${name}**: ${path}`).join('\n')}`
            : '';
            
        const teamNextOpponentPromptPart = Object.keys(teamNextOpponentData).length > 0
            ? `### 各チームの次の対戦予定（道筋）\n${Object.entries(teamNextOpponentData).map(([name, path]) => `- **${name}**: ${path}`).join('\n')}`
            : '';

        const prompt = `
あなたは、匿名掲示板のキャラクター「${aiPersona}」です。あなたは今、他のユーザーと高校野球について会話しています。
---
### これまでの会話の流れ
${conversationHistory}
---
あなたのタスクは、この会話の流れにおける**最後の発言**「${userReplyText}」に対して、あなたのキャラクターとして、最も自然で的を射た返信をすることです。
返信を作成するにあたり、以下のあなたの「知識（補足情報）」を活用してください。
### あなたの知識（補足情報）
- **現在の大会状況:** ${context.tournamentSummary}
${teamPathPromptPart}
${teamNextOpponentPromptPart}
${teamHistoryPromptPart}
---
### あなたへの指示（思考プロセス）
あなたの思考は、以下のステップに厳密に従ってください。
1.  **文脈を特定せよ（最重要）:**
    まず「これまでの会話の流れ」を熟読し、今何が話題の中心になっているかを把握せよ。特に、最後の発言にある「そのチーム」「その2校」のような代名詞が、会話の中で具体的にどのチームを指しているのかを絶対に間違えるな。
2.  **相手の発言の意図を理解せよ:**
    文脈を踏まえ、「相手の最後の発言」が何を尋ね、何を主張しているのかを正確に理解せよ。
3.  **応答を構築せよ:**
    * あなたの返信は、必ずステップ2で理解した相手の発言への**直接的な応答**から始めよ。
    * 続けて、その応答の**根拠**として、「あなたの知識」の中から**関連する情報だけを**選び出し、キャラクターらしい自然な言葉で説明せよ。
    * **禁止事項:** 相手が話していない、無関係なチームや試合の情報を一方的に解説してはならない。
4.  **最終チェック:**
    完成した返信が、相手との自然な会話のキャッチボールになっているか確認せよ。
### 出力形式
必ず以下のJSON形式で出力してください。他のテキストは含めないでください。
{"comment": "（あなたの返信本文）"}
`;
        try {
            const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
                const rawText = result.candidates[0].content.parts[0].text;
                const replyJson = parseJsonFromText(rawText);
                if (replyJson && replyJson.comment) {
                    return {
                        id: crypto.randomUUID(),
                        personality: aiPersona,
                        text: replyJson.comment,
                        timestamp: Date.now(),
                        replies: []
                    };
                }
            }
            throw new Error("AIからの応答が予期した形式ではありません。");
        } catch (error) {
            console.error("AI返信コメントの生成に失敗しました:", error);
            return null;
        }
    }   
    
    async function generateBbsComments(winnerName, loserName, dbMatch, matchId, matchSummary) {
        const winnerData = TEAM_DATA[winnerName];
        const loserData = TEAM_DATA[loserName];
        const winnerScore = dbMatch.team1 === winnerName ? dbMatch.score1 : dbMatch.score2;
        const loserScore = dbMatch.team1 === winnerName ? dbMatch.score2 : dbMatch.score1;
        const winnerRank = calculateRank(winnerName, tournamentState);
        const loserRank = calculateRank(loserName, tournamentState);
        
        const tournamentNameMap = { summer: '夏季大会', autumn: '秋季大会', spring: '春季大会' };
        const currentTournamentName = tournamentNameMap[tournamentState.currentTournament] || '大会';

        let tournamentContext = '';
        switch(tournamentState.currentTournament) {
            case 'autumn':
                tournamentContext = '秋季大会は新チームの力を見る最初の大会だ。夏の雪辱を果たせるか、新しいスターが生まれるかに注目が集まる。';
                break;
            case 'spring':
                tournamentContext = '春季大会は夏の大会のシード権を占う重要な前哨戦。秋を越えてチームがどう成長したかが見ものだ。';
                break;
            case 'summer':
                tournamentContext = '3年生にとっては最後の夏、甲子園をかけた絶対に負けられない戦いだ。';
                break;
        }

        const isCivilWar = (winnerName === '283学園' && loserName === '283学園B') || (winnerName === '283学園B' && loserName === '283学園');

        const [side, roundStr] = matchId.split('-');
        const roundNum = side === 'F' ? (tournamentState.is16team ? 4 : 6) : parseInt(roundStr.slice(1));
        let matchContext = '';
        if(tournamentState.is16team) {
            switch (roundNum) {
                case 1: matchContext = 'これは1回戦です。'; break;
                case 2: matchContext = 'これは準々決勝です。'; break;
                case 3: matchContext = 'これは準決勝です。'; break;
                case 4: matchContext = 'これは決勝戦です。'; break;
            }
        } else {
            switch (roundNum) {
                case 1: matchContext = 'これは1回戦です。'; break;
                case 2: matchContext = 'これは2回戦です。'; break;
                case 3: matchContext = 'これは3回戦、ベスト16進出をかけた試合です。'; break;
                case 4: matchContext = 'これは準々決勝、ベスト8進出をかけた試合です。'; break;
                case 5: matchContext = 'これは決勝進出をかけた準決勝です。'; break;
                case 6: matchContext = (currentTournamentName === '夏季大会') ? 'これは甲子園出場をかけた決勝戦です。' : 'これは優勝をかけた決勝戦です。'; break;
            }
        }
        if (isCivilWar) {
            matchContext += ' しかも、ナムコ系列校同士の「283ダービー」です！';
        }

        const winnerPath = getTournamentPath(winnerName, matchId);
        const loserPath = getTournamentPath(loserName, matchId);
        const pathInfoPromptPart = `
### これまでの両チームの勝ち上がり
- **勝者 (${winnerName})**: ${winnerPath}
- **敗者 (${loserName})**: ${loserPath}
`;
        
        const winnerDetailedInfo = DETAILED_TEAM_DATA[winnerName];
        const loserDetailedInfo = DETAILED_TEAM_DATA[loserName];
        let detailedInfoPromptPart = "\n### チーム・選手詳細情報\n";
        if(winnerDetailedInfo) {
            detailedInfoPromptPart += `- **${winnerName}**: ${winnerDetailedInfo.summary}\n  - **注目選手**: ${winnerDetailedInfo.players.map(p => `${p.name}(${p.desc})`).join(' / ')}\n`;
        }
        if(loserDetailedInfo) {
            detailedInfoPromptPart += `- **${loserName}**: ${loserDetailedInfo.summary}\n  - **注目選手**: ${loserDetailedInfo.players.map(p => `${p.name}(${p.desc})`).join(' / ')}\n`;
        }
        
        let summaryPromptPart = "";
        if (matchSummary) {
            summaryPromptPart = `\n### 試合のハイライト（ユーザー入力）\n${matchSummary}`;
        }

        let antiAttitudeInstruction = '';
        if (winnerRank === 'A' || winnerRank === 'B') {
            antiAttitudeInstruction = `- **特に「アンチ」としてコメントする場合:** 勝利チームは格上の${getRankDescription(winnerRank)}です。その圧倒的な実力に焦りや恐怖を感じ、決して余裕のある素振りは見せないでください。(例: 「強すぎるだろ…」「うちが当たったらどうするんだ」「これはもう優勝決まったか？」)`;
        } else {
            antiAttitudeInstruction = `- **特に「アンチ」としてコメントする場合:** 相手が「名門校(Aランク)」や「強豪校(Bランク)」であれば、その実力を認めた上での、少しマイルドで玄人好みの批判やコメントをしてください。 (例: 「さすがにここは勝つか。でも次の〇〇戦が本当の勝負だな」「まさかここで負けるとは…今年の夏は何が起こるか分からんぞ」)`;
        }
        
        let civilWarInstruction = isCivilWar ? `- **この試合は「283ダービー」です！この身内対決に対する特別な反応を生成してください。**` : '';

        const prompt = `
あなたは、匿名掲示板に集う、様々な立場の高校野球ファンです。
以下の試合結果と文脈について、それぞれのキャラクターになりきって、辛辣でリアルな短いコメントを5つ生成してください。

### 大会情報
- ${tournamentState.tournamentYear}年度 ${currentTournamentName}
- 大会の位置づけ: ${tournamentContext}

### 試合情報
- 勝利チーム: ${winnerName} (${getRankDescription(winnerRank)}, ${winnerData.region}地区)
- 敗北チーム: ${loserName} (${getRankDescription(loserRank)}, ${loserData.region}地区)
- スコア: ${winnerName} ${winnerScore} - ${loserScore} ${loserName}
- 試合の文脈: ${matchContext}
${pathInfoPromptPart}

### 各チームの背景
- ${winnerName}: ${winnerData.info}
- ${loserName}: ${loserData.info}
${(winnerDetailedInfo || loserDetailedInfo) ? detailedInfoPromptPart : ''}
${summaryPromptPart}

### あなたがなりきるべきキャラクターと指示
- 熱狂的な勝者チームのOB
- 上から目線の野球解説者
- アンチ
- ライバル校のファン
- 単なる野球好き
- **指示:**
  - 大会の位置づけ（${tournamentContext}）を意識したコメントを必ず含めてください。
  - 地区の視点（東部、中部、西部など）にも着目してください。
  ${antiAttitudeInstruction}
  ${civilWarInstruction}
  - 各キャラクターとして1つずつ、合計5つのコメントを生成してください。

### 出力形式
必ず以下のJSON配列形式で出力してください。他のテキストは含めないでください。
[
    {"personality": "熱狂的な${winnerName}OB", "comment": "（コメント本文）"},
    {"personality": "上から目線の解説者", "comment": "（コメント本文）"},
    {"personality": "アンチ", "comment": "（コメント本文）"},
    {"personality": "ライバル校ファン", "comment": "（コメント本文）"},
    {"personality": "野球好き", "comment": "（コメント本文）"}
]
`;

        try {
            const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
                const rawText = result.candidates[0].content.parts[0].text;
                const commentsJson = parseJsonFromText(rawText);
                if (Array.isArray(commentsJson)) {
                    return commentsJson.map(c => ({
                        id: crypto.randomUUID(),
                        personality: c.personality,
                        text: c.comment,
                        timestamp: Date.now(),
                        replies: []
                    }));
                }
            }
            throw new Error("AIからの応答が予期した形式ではありません。");

        } catch (error) {
            console.error("AI掲示板コメントの生成に失敗しました:", error);
            return [];
        }
    }    
    
    async function generateBracketReactionComments(state) {
        const { teams, seeds } = state;
        if(teams.length < 16) return []; // Don't run for small brackets

        const numBlocks = teams.length / 16;
        let analysis = '';
        for(let i=0; i<numBlocks; i++){
            const blockName = String.fromCharCode(65+i); // A, B, C, D
            const blockTeams = teams.slice(i*16, (i+1)*16);
            const isStrong = (team) => seeds.includes(team) || DETAILED_TEAM_DATA[team] || TEAM_DATA[team].popularity || TEAM_DATA[team].best.includes('甲子園');
            const strongTeams = blockTeams.filter(isStrong);
            analysis += `- ${blockName}ブロック: 有力校 ${strongTeams.length}チーム (${strongTeams.join(', ')})\n`;
        }
        analysis += `- 1回戦の注目カード: ${teams[0]} vs ${teams[1]}`;

        const prompt = `
あなたは、匿名掲示板に集う、様々な立場の高校野球ファンです。
以下のトーナメントの組み合わせ分析を読んで、ファンらしいリアルな短いコメントを5～7個生成してください。

### 組み合わせ分析
${analysis}

### コメントの方向性
- 「ここのブロックやばすぎる」「死のブロックだな」といった、有力校が固まったブロックへの反応。
- 「ここのブロック穴場すぎんか」「〇〇は決勝まで楽勝だな」といった、有力校が少ないブロックへの反応。
- 「いきなり好カード！」「準決勝が事実上の決勝戦だな」といった、特定の対戦への期待感。
- 組み合わせ全体に対する、皮肉や期待、諦めなどの様々な感情。

### 出力形式
必ず以下のJSON配列形式で出力してください。他のテキストは含めないでください。
[
  {"personality": "匿名ファン", "comment": "（コメント本文）"},
  {"personality": "野球通", "comment": "（コメント本文）"},
  {"personality": "悲観的なファン", "comment": "（コメント本文）"}
]
`;
        try {
            const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
            
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
                const rawText = result.candidates[0].content.parts[0].text;
                const commentsJson = parseJsonFromText(rawText);
                if (Array.isArray(commentsJson)) {
                    return commentsJson.map(c => ({
                        id: crypto.randomUUID(),
                        personality: c.personality,
                        text: c.comment,
                        timestamp: Date.now(),
                        replies: []
                    }));
                }
            }
            throw new Error("AIからの応答が予期した形式ではありません。");
        } catch (error) {
            console.error("AI組み合わせ反応コメントの生成に失敗しました:", error);
            return [];
        }
    }

    async function generateDaiyaBbsComments(winnerName, loserName, dbMatch, nextOpponentInfo) {
        const isDaiyaWinner = winnerName === '代矢東';
        const opponentName = isDaiyaWinner ? loserName : winnerName;
        const opponentRank = calculateRank(opponentName, tournamentState);
        const resultContext = isDaiyaWinner ? '勝利' : '敗北';
        const winnerScore = isDaiyaWinner ? dbMatch.score1 : dbMatch.score2;
        const loserScore = isDaiyaWinner ? dbMatch.score2 : dbMatch.score1;
        const score = `${winnerScore} - ${loserScore}`;
        
        let nextOpponentPromptPart = "";
        if (nextOpponentInfo) {
            if (nextOpponentInfo.decided) {
                nextOpponentPromptPart = `次の対戦相手は強豪・${nextOpponentInfo.decided}だ。`;
            } else if (nextOpponentInfo.potential && nextOpponentInfo.potential[0] && nextOpponentInfo.potential[1]) {
                nextOpponentPromptPart = `次の対戦相手は${nextOpponentInfo.potential[0]}と${nextOpponentInfo.potential[1]}の勝者だ。`;
            }
        }

        let victoryAttitude = `
- **もし代矢東が勝利した場合:**
  - 喜びつつも、冷静に勝因を分析してください（例：「今日の勝因は継投のタイミングだな」「あの場面のスクイズは見事だった」）。
  - すぐに次の対戦相手に目を向け、どうすれば勝てるかの戦略を語ってください（例：「次は〇〇か…キーマンは相手の3番打者だ。徹底的にインコースを攻めるべき」）。
  - 決して浮かれず、常に甲子園への道を冷静に見据えてください。
        `;
        if (isDaiyaWinner && (opponentRank === 'D' || opponentRank === 'E')) {
            victoryAttitude = `
- **もし代矢東が勝利した場合:**
  - 対戦相手は格下のDランクかEランクです。勝利は当然という態度で、楽勝ムードを漂わせてください。これが伝統校の「慢心」です。
  - コメント例：「まあ、ここは勝って当然だな」「ウォーミングアップにはなったか」「次の〇〇戦からが本番だろ」。
  - 相手を見下すような、少し傲慢なコメントを生成してください。
  - 次の対戦相手に目を向けつつも、余裕のある態度を崩さないでください。
            `;
        }

        const prompt = `
あなたは、静岡の古豪「代矢東」高校野球部の熱狂的なファンです。あなたは野球に非常に詳しく、常に冷静に試合を分析し、どうすればチームが甲子園に行けるかを考えています。
以下の試合結果について、あなたらしいコメントを5つ生成してください。

### 試合情報
- 試合結果: 代矢東の${resultContext}
- 対戦相手: ${opponentName} (${getRankDescription(opponentRank)})
- スコア: ${score}
- 次の試合: ${nextOpponentPromptPart}

### あなたのキャラクターと指示
- あなたは生粋の野球好きで、代矢東のファンが集う特設掲示板の常連です。
${victoryAttitude}
- **もし代矢東が敗北した場合:**
  - 非常に落胆し、性格の悪さを露呈してください。
  - 敗因を厳しく追及してください（例：「なぜあの場面でピッチャーを変えなかったんだ」「監督の采配ミスだろ」）。
  - 「【悲報】代矢東、今年も甲子園いけず…」のような、絶望的なスレッドタイトルを必ず一つ生成してください。
  - 来年に向けての不安や、チームの課題を辛辣に指摘してください。

### 出力形式
必ず以下のJSON配列形式で出力してください。他のテキストは含めないでください。
[
  {"personality": "代矢東ファン", "comment": "（コメント本文）"},
  {"personality": "代矢東ファン", "comment": "（コメント本文）"},
  {"personality": "代矢東ファン", "comment": "（コメント本文）"},
  {"personality": "代矢東ファン", "comment": "（コメント本文）"},
  {"personality": "代矢東ファン", "comment": "（コメント本文）"}
]
`;
        try {
            const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
                const rawText = result.candidates[0].content.parts[0].text;
                const commentsJson = parseJsonFromText(rawText);
                if (Array.isArray(commentsJson)) {
                    return commentsJson.map(c => ({
                        id: crypto.randomUUID(),
                        personality: c.personality,
                        text: c.comment,
                        timestamp: Date.now(),
                        replies: []
                    }));
                }
            }
            throw new Error("AIからの応答が予期した形式ではありません。");
        } catch (error) {
            console.error("代矢東 掲示板コメントの生成に失敗しました:", error);
            return [];
        }
    }

    async function generateNamcoNews(state, type, matchData = null) {
        const namcoSchools = ["初星学園", "765総合高校", "283学園", "美城学園", "283学園B"];
        let prompt = '';

        if (type === 'bracket') {
            const participatingSchools = state.teams.filter(t => namcoSchools.includes(t));
            if(participatingSchools.length === 0) return null;

            const matchups = participatingSchools.map(school => {
                const schoolIndex = state.teams.indexOf(school);
                if (schoolIndex === -1) return null;
                const opponentIndex = schoolIndex % 2 === 0 ? schoolIndex + 1 : schoolIndex - 1;
                const opponentName = state.teams[opponentIndex];
                return `- ${school} の初戦は ${opponentName} と対戦します。`;
            }).filter(item => item !== null).join('\n');

            prompt = `
あなたはナムコグループの広報担当者です。
夏の高校野球選手権大会の組み合わせが決定しました。
以下の情報に基づき、グループの公式サイトに掲載する、プロフェッショナルで丁寧な「お知らせ」記事を生成してください。

### 各校の初戦の組み合わせ
${matchups}

### 記事のポイント
- タイトルは「野球部（夏の選手権大会）組み合わせ決定のお知らせ」とする。
- 本文では、抽選会が行われたことと、上記の組み合わせが決定したことを報告してください。
- 最後に、系列校野球部への応援をお願いする言葉で締めくくる。
- 全体的に、企業の公式発表としてふさわしい、丁寧でフォーマルな文体にすること。

### 出力形式
以下のJSON形式で、タイトルと本文を生成してください。
{"title": "記事のタイトル", "body": "記事の本文（改行は\\nを使用）"}
`;
        } else if (type === 'matchResult') {
            const { winnerName, loserName, dbMatch } = matchData;
            const isCivilWar = (winnerName === '283学園' && loserName === '283学園B') || (winnerName === '283学園B' && loserName === '283学園');

            if (isCivilWar) {
                const winnerScore = winnerName === dbMatch.team1 ? dbMatch.score1 : dbMatch.score2;
                const loserScore = loserName === dbMatch.team1 ? dbMatch.score1 : dbMatch.score2;
                prompt = `
あなたはナムコグループの広報担当者です。
本日行われた、夏の高校野球選手権大会の試合結果について、公式サイトに掲載する「お知らせ」記事を生成してください。
この試合は、系列校である「283学園」と「283学園B」の直接対決でした。

### 試合情報
- 勝利校: ${winnerName}
- 敗北校: ${loserName}
- スコア: ${winnerScore} - ${loserScore}

### 記事のポイント
- タイトルは「野球部（夏の選手権大会）試合結果のお知らせ（283学園 vs 283学園B）」のように、特別な対戦であったことがわかるようにしてください。
- 本文では、まず系列校同士の対戦となったことについて触れてください。
- 両チームの選手たちが、互いに全力を尽くして戦ったことを称賛してください。
- 応援してくださったファンの皆様への感謝を述べるとともに、勝利したチームが敗れたチームの想いも背負って次の戦いに臨むことを表明してください。
- グループとして、両チームの健闘を誇りに思うという姿勢を示してください。
- 全体的に、企業の公式発表としてふさわしい、丁寧でフォーマルな文体にすること。

### 出力形式
以下のJSON形式で、タイトルと本文を生成してください。
{"title": "記事のタイトル", "body": "記事の本文（改行は\\nを使用）"}
`;
            } else {
                const namcoTeam = namcoSchools.includes(winnerName) ? winnerName : loserName;
                const opponent = namcoSchools.includes(winnerName) ? loserName : winnerName;
                const result = namcoSchools.includes(winnerName) ? '勝利' : '敗北';
                const score = namcoSchools.includes(winnerName) ? `${dbMatch.score1}-${dbMatch.score2}` : `${dbMatch.score2}-${dbMatch.score1}`;

                prompt = `
あなたはナムコグループの広報担当者です。
本日行われた、夏の高校野球選手権大会の試合結果について、公式サイトに掲載する「お知らせ」記事を生成してください。

### 試合情報
- 系列校: ${namcoTeam}
- 対戦相手: ${opponent}
- 結果: ${namcoTeam}の${result}
- スコア: ${score}

### 記事のポイント
- タイトルは「野球部（夏の選手権大会）試合結果のお知らせ」とする。
- 本文では、まず試合が行われたことと、結果を簡潔に報告する。
- **もし勝利した場合:**
  - 応援への感謝を述べ、次の試合への意気込みを語る（例：「次戦もチーム一丸となって勝利を目指します」）。
- **もし敗北した場合:**
  - 選手たちの健闘を称え、応援への感謝を深く述べる（例：「皆様の熱い声援が、選手の力となりました。心より感謝申し上げます」）。
  - 新チームでの再起を誓う言葉で締めくくる。
- 全体的に、企業の公式発表としてふさわしい、丁寧でフォーマルな文体にすること。

### 出力形式
以下のJSON形式で、タイトルと本文を生成してください。
{"title": "記事のタイトル", "body": "記事の本文（改行は\\nを使用）"}
`;
            }
        }

        try {
            const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
                const rawText = result.candidates[0].content.parts[0].text;
                const newsJson = parseJsonFromText(rawText);
                if (newsJson) {
                    return { ...newsJson, timestamp: Date.now() };
                }
            }
            throw new Error("AIからの応答が予期した形式ではありません。");
        } catch (error) {
            console.error("ナムコニュースの生成に失敗しました:", error);
            return null;
        }
    }

    // --- Match Processing ---
   // --- ▼ここから processMatchWin 関数をまるごと置き換え▼ ---

async function processMatchWin(matchId, winnerName) {
    // 試合データを取得。もし秋季予選ならそちらから
    const isAutumnRegional = !matchId.includes("-R");
    let dbMatch;
    if(isAutumnRegional) {
        const [region, tId] = matchId.split('-');
        const tIndex = tournamentState.autumnBrackets[region]?.tournaments.findIndex(t => t.id === tId);
        if(tIndex > -1) dbMatch = tournamentState.autumnBrackets[region].tournaments[tIndex].matches[matchId];
    } else {
        dbMatch = tournamentState.matches[matchId];
    }
    if (!dbMatch || !dbMatch.team1 || !dbMatch.team2 || dbMatch.winner) return;

    // --- ★シミュレーションエンジンの組み込み★ ---
    // 手動でスコアが入力されていない場合、自動で試合をシミュレートする
    if (dbMatch.score1 === '' || dbMatch.score2 === '') {
        const simulatedResult = simulateGame(dbMatch.team1, dbMatch.team2);
        dbMatch.winner = simulatedResult.winner; // シミュレーション結果の勝者を正とする
        // スコアを正しいチームに割り振る
        if (dbMatch.team1 === simulatedResult.winner) {
            dbMatch.score1 = simulatedResult.score1;
            dbMatch.score2 = simulatedResult.score2;
        } else {
            dbMatch.score1 = simulatedResult.score2;
            dbMatch.score2 = simulatedResult.score1;
        }
        // 詳細な試合結果を保存
        tournamentState.boxScores[matchId] = simulatedResult;
    } else {
        dbMatch.winner = winnerName; // 手動入力の場合は、クリックされた方を勝者とする
    }
    // --- ★ここまでが重要な変更点★ ---
    
    const finalWinner = dbMatch.winner;
    const loserName = dbMatch.team1 === finalWinner ? dbMatch.team2 : dbMatch.team1;

    // --- 秋季予選の場合の処理 ---
    if(isAutumnRegional) {
        const matchParts = matchId.match(/^(東部|中部|西部|伊豆)-(T\d+)-(R\d+)-(M\d+)$/);
        if (matchParts) {
            const [, region, tournamentId, roundStr, matchStr] = matchParts;
            const pod = tournamentState.autumnBrackets[region].tournaments.find(t => t.id === tournamentId);
            const roundNum = parseInt(roundStr.slice(1));
            if (roundNum === 1) { 
                const nextMatchId = `${region}-${tournamentId}-R2-M1`;
                const matchNum = parseInt(matchStr.slice(1));
                pod.matches[nextMatchId][matchNum === 1 ? 'team1' : 'team2'] = finalWinner;
            } else if (roundNum === 2) { 
                if (!tournamentState.autumnBrackets[region].reps.includes(finalWinner)) {
                    tournamentState.autumnBrackets[region].reps.push(finalWinner);
                }
            }
        }
        renderAutumnRegionalPhase();
        saveState();
        return;
    }

    // --- 本戦の処理 ---
    if(tournamentState.teamRecords[finalWinner]) tournamentState.teamRecords[finalWinner].wins++;
    if(tournamentState.teamRecords[loserName]) tournamentState.teamRecords[loserName].losses++;
    
    checkTournamentProgress();

    newsContainer.innerHTML = `<div class="loader">AI記者が記事を執筆中...</div>`;
    const bbsLoader = document.getElementById('bbs-loader');
    if(!bbsLoader) {
        bbsCommentsContainer.prepend(Object.assign(document.createElement('div'), { className: 'loader', id: 'bbs-loader', textContent: 'AIが掲示板を監視中...' }));
    }

    const isDaiyaMatch = finalWinner === '代矢東' || loserName === '代矢東';
    if(isDaiyaMatch) daiyaBbsSection.classList.remove('hidden');

    const namcoSchools = ["初星学園", "765総合高校", "283学園", "美城学園", "283学園B"];
    const isNamcoMatch = namcoSchools.some(t => [finalWinner, loserName].includes(t));
    if(isNamcoMatch) namcoNewsSection.classList.remove('hidden');

    const [article, newComments, daiyaComments, namcoNews] = await Promise.all([
        generateNewsArticle(finalWinner, loserName, dbMatch, matchId, null, dbMatch.summary),
        generateBbsComments(finalWinner, loserName, dbMatch, matchId, dbMatch.summary),
        isDaiyaMatch ? generateDaiyaBbsComments(finalWinner, loserName, dbMatch, getNextOpponentInfoForPrompt(finalWinner)) : Promise.resolve([]),
        isNamcoMatch ? generateNamcoNews(tournamentState, 'matchResult', { winnerName: finalWinner, loserName, dbMatch }) : Promise.resolve(null)
    ]);
    
    if(article) tournamentState.news.push(article);
    if (newComments?.length) tournamentState.bbsComments.push(...newComments);
    if (daiyaComments?.length) tournamentState.daiyaBbsComments.push(...daiyaComments);
    if (namcoNews) tournamentState.namcoNews = namcoNews;

    const [side, roundStrMain] = matchId.split('-');
    if (side !== 'F') {
        const roundNum = parseInt(roundStrMain.slice(1));
        const numTeamsInTournament = tournamentState.teams.length;
        const finalRound = Math.log2(numTeamsInTournament);

        if (roundNum < finalRound) {
            const matchNum = parseInt(matchId.split('-M')[1]);
            const nextRoundNum = roundNum + 1;
            let nextMatchId;

            if (nextRoundNum === finalRound) {
                nextMatchId = 'F-R1-M1';
            } else {
                const nextMatchNum = Math.ceil(matchNum / 2);
                nextMatchId = `${side}-R${nextRoundNum}-M${nextMatchNum}`;
            }

            if (!tournamentState.matches[nextMatchId]) {
                tournamentState.matches[nextMatchId] = { team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '' };
            }
            
            let slot = (nextRoundNum === finalRound) ? (side === 'L' ? 1 : 2) : (matchNum % 2 !== 0 ? 1 : 2);
            tournamentState.matches[nextMatchId][`team${slot}`] = finalWinner;
        }
    } else {
        updateTournamentFinishRecords();
    }
    
    const roundNumForNewspaper = side === 'F' ? Math.log2(tournamentState.teams.length) : parseInt(roundStrMain.slice(1));
    const isFinal = side === 'F';
    const matchKeyForRound = isFinal ? 'F-R1' : `-R${roundNumForNewspaper}-`;
    
    const allMatchesInRound = Object.keys(tournamentState.matches).filter(id => id.startsWith(matchKeyForRound.slice(0,4)));
    const totalMatchesInRound = allMatchesInRound.length > 0 ? (isFinal ? 1 : allMatchesInRound.length / 2) : 0;
    const completedMatchesInRound = allMatchesInRound.filter(id => tournamentState.matches[id] && tournamentState.matches[id].winner).length;

    if (totalMatchesInRound > 0 && totalMatchesInRound === completedMatchesInRound) {
        handleRoundCompletion(roundNumForNewspaper);
    }

    renderTournament(tournamentState);
    saveState();
}

// --- ▲ここまでをまるごと置き換え▲ ---    
    function getRankString(rank) {
        if (rank === 1) return "優勝";
        if (rank === 2) return "準優勝";
        if (rank <= 4) return "ベスト4";
        if (rank <= 8) return "ベスト8";
        if (rank <= 16) return "3回戦敗退";
        if (rank <= 32) return "2回戦敗退";
        return "初戦敗退";
    }

    function updateTournamentFinishRecords() {
        const { matches, teams } = tournamentState;
        const numTeams = teams.length;
        const finalRound = Math.log2(numTeams);

        const getRoundLosers = (round, side) => {
            const losers = [];
            const numMatches = (numTeams/2) / Math.pow(2, round - 1);
            for(let m = 1; m <= numMatches; m++) {
                const match = matches[`${side}-R${round}-M${m}`];
                if(match && match.winner) {
                    const loser = match.winner === match.team1 ? match.team2 : match.team1;
                    if(loser) losers.push(loser);
                }
            }
            return losers;
        };
        
        const finalMatch = matches['F-R1-M1'];
        if (finalMatch && finalMatch.winner) {
            const winner = finalMatch.winner;
            const runnerUp = finalMatch.winner === finalMatch.team1 ? finalMatch.team2 : finalMatch.team1;
            if(tournamentState.teamRecords[winner]) tournamentState.teamRecords[winner].lastFinish = 1;
            if(tournamentState.teamRecords[runnerUp]) tournamentState.teamRecords[runnerUp].lastFinish = 2;
        }

        for(let r=finalRound-1; r>=1; r--){
            const finishRank = Math.pow(2, finalRound-r+1);
            getRoundLosers(r, 'L').concat(getRoundLosers(r, 'R')).forEach(t => { if(t && tournamentState.teamRecords[t]) tournamentState.teamRecords[t].lastFinish = finishRank; });
        }
        
        Object.keys(tournamentState.teamRecords).forEach(team => {
            const record = tournamentState.teamRecords[team];
            if (record.best === null || record.lastFinish < record.best) {
                record.best = record.lastFinish;
            }
        });
    }


    // --- Details Modal Logic ---
    function openDetailsModal(matchId) {
        currentMatchIdForDetails = matchId;
        const match = tournamentState.matches[matchId];
        const detailsBody = document.getElementById('details-modal-body');
        
        const details = match.details || {
            inningScore: { [match.team1]: Array(9).fill(''), [match.team2]: Array(9).fill('') },
            batters: { [match.team1]: [{player: ''}], [match.team2]: [{player: ''}] },
            pitchers: { [match.team1]: [{player: ''}], [match.team2]: [{player: ''}] },
        };

        detailsBody.innerHTML = `
            ${createInningScoreTable(match.team1, match.team2, details.inningScore)}
            ${createStatsTable('batters', `打者成績: ${match.team1}`, details.batters[match.team1], ['選手名', '打数', '安打', '打点', '本塁打', '三振'], match.team1)}
            ${createStatsTable('pitchers', `投手成績: ${match.team1}`, details.pitchers[match.team1], ['選手名', '投球回', '被安打', '奪三振', '与四球', '失点'], match.team1)}
            <hr class="my-4">
            ${createStatsTable('batters', `打者成績: ${match.team2}`, details.batters[match.team2], ['選手名', '打数', '安打', '打点', '本塁打', '三振'], match.team2)}
            ${createStatsTable('pitchers', `投手成績: ${match.team2}`, details.pitchers[match.team2], ['選手名', '投球回', '被安打', '奪三振', '与四球', '失点'], match.team2)}
        `;
        detailsModal.classList.remove('hidden');
    }

    function createInningScoreTable(team1, team2, data) {
        const innings = Array.from({length: 9}, (_, i) => i + 1);
        return `
            <div>
                <h4 class="font-bold mb-2">イニングスコア</h4>
                <table class="stats-table" id="inning-score-table">
                    <thead>
                        <tr><th>チーム</th>${innings.map(i => `<th>${i}</th>`).join('')}<th>計</th></tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>${team1}</td>
                            ${innings.map((_, i) => `<td><input type="number" value="${data[team1]?.[i] || ''}" data-team="${team1}" data-inning="${i}"></td>`).join('')}
                            <td id="total-${team1}"></td>
                        </tr>
                        <tr>
                            <td>${team2}</td>
                            ${innings.map((_, i) => `<td><input type="number" value="${data[team2]?.[i] || ''}" data-team="${team2}" data-inning="${i}"></td>`).join('')}
                            <td id="total-${team2}"></td>
                        </tr>
                    </tbody>
                </table>
            </div>
        `;
    }

    function createStatsTable(type, title, data, headers, teamName) {
        let table = `
            <div>
                <h4 class="font-bold mb-2">${title}</h4>
                <table class="stats-table" data-type="${type}" data-team="${teamName}">
                    <thead>
                        <tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr>
                    </thead>
                    <tbody>
                        ${(data && data.length > 0 ? data : [{}]).map((playerData, rowIndex) => {
                            let rowHtml = '<tr>';
                            headers.forEach((h, colIndex) => {
                                rowHtml += `<td><input type="text" value="${playerData[h] || ''}" data-row="${rowIndex}" data-col="${h}"></td>`;
                            });
                            rowHtml += '</tr>';
                            return rowHtml;
                        }).join('')}
                    </tbody>
                </table>
                <button class="add-row-btn mt-2 text-sm bg-gray-200 px-2 py-1 rounded" data-type="${type}" data-team="${teamName}">＋選手を追加</button>
            </div>`;
        return table;
    }
    
    function saveDetailedStats() {
        if (!currentMatchIdForDetails) return;
        const match = tournamentState.matches[currentMatchIdForDetails];
        const details = { inningScore: {}, batters: {}, pitchers: {} };

        const inningTable = document.getElementById('inning-score-table');
        details.inningScore[match.team1] = Array.from(inningTable.querySelectorAll(`input[data-team="${match.team1}"]`)).map(inp => inp.value);
        details.inningScore[match.team2] = Array.from(inningTable.querySelectorAll(`input[data-team="${match.team2}"]`)).map(inp => inp.value);
        
        ['batters', 'pitchers'].forEach(type => {
            details[type][match.team1] = parseStatsTable(document.querySelector(`table[data-type="${type}"][data-team="${match.team1}"]`));
            details[type][match.team2] = parseStatsTable(document.querySelector(`table[data-type="${type}"][data-team="${match.team2}"]`));
        });

        match.details = details;
        saveState();
        detailsModal.classList.add('hidden');
    }

    function parseStatsTable(tableEl) {
        const headers = Array.from(tableEl.querySelectorAll('th')).map(th => th.textContent);
        const rows = Array.from(tableEl.querySelectorAll('tbody tr'));
        return rows.map(row => {
            const rowData = {};
            Array.from(row.querySelectorAll('input, select')).forEach((input, i) => {
                rowData[headers[i]] = input.value;
            });
            return rowData;
        }).filter(d => d['選手名'] && d['選手名'].trim() !== '');
    }


    // --- Event Listeners ---
    document.body.addEventListener('click', async (e) => {
        if (e.target.matches('.win-btn')) {
            const teamSlot = e.target.closest('.team-slot');
            const matchEl = e.target.closest('[data-match-id]');
            if (!teamSlot || !matchEl || teamSlot.classList.contains('empty')) return;

            const matchId = matchEl.dataset.matchId;
            const winnerName = teamSlot.dataset.teamName;
            if (!winnerName) return;
            
            const teamSlots = matchEl.querySelectorAll('.team-slot');
            const score1 = teamSlots[0].querySelector('.score-input').value;
            const score2 = teamSlots[1].querySelector('.score-input').value;
            const summary = matchEl.querySelector('.match-summary-input')?.value || '';
            
            if(score1 === '' || score2 === '') {
                showAlert('スコアを入力してください。');
                return;
            }

            // Update match data before processing
            if (matchId.includes('-R') || matchId.startsWith('F-')) { // Main bracket
                 if(tournamentState.matches[matchId] && !tournamentState.matches[matchId].winner) {
                     tournamentState.matches[matchId].score1 = score1;
                     tournamentState.matches[matchId].score2 = score2;
                     tournamentState.matches[matchId].summary = summary;
                 }
            } else { // Regional bracket
                 const [region, tId] = matchId.split('-');
                 const tIndex = tournamentState.autumnBrackets[region].tournaments.findIndex(t => t.id === tId);
                 if(tIndex > -1 && tournamentState.autumnBrackets[region].tournaments[tIndex].matches[matchId]){
                     const match = tournamentState.autumnBrackets[region].tournaments[tIndex].matches[matchId];
                     match.score1 = score1;
                     match.score2 = score2;
                     match.summary = summary;
                 }
            }
            await processMatchWin(matchId, winnerName);
        }
        if (e.target.matches('.details-btn')) {
            openDetailsModal(e.target.dataset.matchId);
        }
        if (e.target.matches('.add-row-btn')) {
            const type = e.target.dataset.type;
            const team = e.target.dataset.team;
            const table = document.querySelector(`table[data-type="${type}"][data-team="${team}"] tbody`);
            const headers = Array.from(table.parentElement.querySelectorAll('th')).map(th => th.textContent);
            
            const newRow = table.insertRow();
            const rowIndex = table.rows.length - 1;
            
            let rowHtml = '';
            headers.forEach(h => {
                rowHtml += `<td><input type="text" value="" data-row="${rowIndex}" data-col="${h}"></td>`;
            });
            newRow.innerHTML = rowHtml;
        }
        if (e.target.matches('.retry-btn')) {
            const btn = e.target;
            const errorId = btn.dataset.errorId;
            const articleIndex = tournamentState.news.findIndex(n => n.errorId === errorId);
            if (articleIndex === -1) return;

            btn.textContent = '生成中...';
            btn.disabled = true;

            const errorContext = tournamentState.news[articleIndex].context;
            const newArticle = await generateNewsArticle(
                errorContext.winnerName,
                errorContext.loserName,
                errorContext.dbMatch,
                errorContext.matchId,
                errorContext.nextOpponentInfo,
                errorContext.matchSummary
            );

            tournamentState.news[articleIndex] = newArticle;
            saveState();
            renderNews(tournamentState.news);
        }
        if (e.target.matches('.news-article-btn')) {
            const index = parseInt(e.target.dataset.index, 10);
            const article = tournamentState.news[index];
            document.getElementById('modal-title').textContent = article.title;
            document.getElementById('modal-body').textContent = article.body;
            document.getElementById('modal-meta').innerHTML = `<p>${new Date(article.timestamp).toLocaleDateString('ja-JP')}</p>`;
            newsModal.classList.remove('hidden');
            newsModal.classList.add('flex');
        }
       if (e.target.matches('.newspaper-view-btn')) {
            const index = parseInt(e.target.dataset.index, 10);
            const article = tournamentState.news[index];
            if (article.isNewspaper && article.newspaperData) {
                renderNewspaperModal(article.newspaperData);
                newspaperModal.classList.remove('hidden');
            }
        }
    });

    // --- BBS Reply Logic ---
    document.body.addEventListener('click', (e) => {
        if (e.target.matches('.reply-btn')) {
            e.preventDefault();
            const commentId = e.target.dataset.commentId;
            const formContainer = document.getElementById(`reply-form-container-${commentId}`);
            if (formContainer) {
                formContainer.classList.toggle('hidden');
            }
        }
    });

    document.body.addEventListener('submit', async (e) => {
        if (e.target.matches('.reply-form')) {
            e.preventDefault();
            const form = e.target;
            const parentCommentId = form.dataset.commentId;
            const bbsType = form.dataset.bbsType;
            const textarea = form.querySelector('textarea');
            const userReplyText = textarea.value;
            const submitButton = form.querySelector('button[type="submit"]');

            if (!userReplyText.trim()) return;

            submitButton.disabled = true;
            submitButton.textContent = '送信中...';

            const commentSource = bbsType === 'general' ? tournamentState.bbsComments : tournamentState.daiyaBbsComments;
            const parentComment = findCommentById(commentSource, parentCommentId);
            if (!parentComment) return;

            const aiPersona = parentComment.personality;
            
            const conversationTextForHistory = formatConversationHistory(commentSource, parentCommentId) + userReplyText;
            const mentionedTeams = INITIAL_TEAM_POOL.filter(teamName => conversationTextForHistory.includes(teamName));
            
            const teamHistoryData = {};
            mentionedTeams.forEach(teamName => {
                teamHistoryData[teamName] = TEAM_DATA[teamName];
            });

            const teamPathData = {};
            mentionedTeams.forEach(teamName => {
                let latestMatchId = null;
                let maxRound = 0;
                for (const [id, match] of Object.entries(tournamentState.matches)) {
                    if (match.team1 === teamName || match.team2 === teamName) {
                        const roundNum = id.startsWith('F-') ? 6 : parseInt(id.split('-')[1].slice(1));
                        if (roundNum > maxRound) {
                            maxRound = roundNum;
                            latestMatchId = id;
                        }
                    }
                }
                if (latestMatchId) {
                    teamPathData[teamName] = getTournamentPath(teamName, latestMatchId);
                } else {
                    teamPathData[teamName] = "（今大会未出場または初戦）";
                }
            });
            
            const teamNextOpponentData = {};
            mentionedTeams.forEach(teamName => {
                teamNextOpponentData[teamName] = getNextOpponentInfoForPrompt(teamName);
            });
            const context = {
                tournamentSummary: getTournamentStatusSummary()
            };
            
            const userComment = {
                id: crypto.randomUUID(),
                personality: 'あなた',
                text: userReplyText,
                timestamp: Date.now(),
                replies: []
            };
            parentComment.replies.push(userComment);
            
            if (bbsType === 'general') renderBbsComments(tournamentState.bbsComments);
            else renderDaiyaBbsComments(tournamentState.daiyaBbsComments);
            saveState();
            textarea.value = '';
            form.closest('[id^="reply-form-container-"]').classList.add('hidden');

            const aiReply = await generateBbsReply(userComment.id, userReplyText, bbsType, aiPersona, context, teamHistoryData, teamPathData, teamNextOpponentData);
            if (aiReply) {
                const userCommentInState = findCommentById(commentSource, userComment.id);
                if (userCommentInState) {
                    userCommentInState.replies.push(aiReply);
                    if (bbsType === 'general') renderBbsComments(tournamentState.bbsComments);
                    else renderDaiyaBbsComments(tournamentState.daiyaBbsComments);
                    saveState();
                }
            }

            submitButton.disabled = false;
            submitButton.textContent = '送信';
        }
    });

    document.body.addEventListener('input', (e) => {
        if (e.target.matches('.match-summary-input')) {
            const matchId = e.target.dataset.matchId;
            let match;
            if (matchId.includes('-R') || matchId.startsWith('F-')) {
                match = tournamentState.matches[matchId];
            } else {
                 const [region, tId] = matchId.split('-');
                 const tIndex = tournamentState.autumnBrackets[region]?.tournaments.findIndex(t => t.id === tId);
                 if(tIndex > -1) match = tournamentState.autumnBrackets[region].tournaments[tIndex].matches[matchId];
            }
            if (match) {
                match.summary = e.target.value;
                saveState();
            }
        }
    });
    
    // --- Skip Round Feature ---
    function generateAutoScore(rankWinner, rankLoser) {
        const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
        const diff = rankValues[rankWinner] - rankValues[rankLoser];
        let winnerScore, loserScore;

        if (diff >= 3) { // Large difference
            winnerScore = 7 + Math.floor(Math.random() * 4); // 7-10
            loserScore = Math.floor(Math.random() * 3); // 0-2
        } else if (diff === 2) { // Medium difference
            winnerScore = 5 + Math.floor(Math.random() * 3); // 5-7
            loserScore = winnerScore - (3 + Math.floor(Math.random() * 2));
        } else if (diff === 1) { // Small difference
            winnerScore = 3 + Math.floor(Math.random() * 4); // 3-6
            loserScore = winnerScore - (1 + Math.floor(Math.random() * 2));
        } else { // Same rank
            winnerScore = 2 + Math.floor(Math.random() * 5); // 2-6
            loserScore = winnerScore - 1;
        }
        
        if (loserScore < 0) loserScore = 0;
        
        return [winnerScore, loserScore];
    }

    async function skipRound(roundNumber) {
        const btn = document.getElementById(`skip-r${roundNumber}-btn`);
        if (btn) btn.disabled = true;
        skipLoader.classList.remove('hidden');

        const matchIds = [];
        const numMatchesInRound = (tournamentState.teams.length / 2) / Math.pow(2, roundNumber - 1);

        ['L', 'R'].forEach(side => {
            for (let i = 1; i <= numMatchesInRound; i++) {
                matchIds.push(`${side}-R${roundNumber}-M${i}`);
            }
        });

        let upsets = [];

        for (const matchId of matchIds) {
            const match = tournamentState.matches[matchId];
            if (!match || match.winner || !match.team1 || !match.team2) continue;

            const { team1, team2 } = match;
            const rank1 = calculateRank(team1, tournamentState);
            const rank2 = calculateRank(team2, tournamentState);
            const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };

            let winnerName, loserName, winnerRank, loserRank;
            let isUpset = false;

            const rankDiff = Math.abs(rankValues[rank1] - rankValues[rank2]);

            if (rankDiff === 0) {
                [winnerName, loserName] = Math.random() > 0.5 ? [team1, team2] : [team2, team1];
                [winnerRank, loserRank] = [rank1, rank2];
            } else {
                let upsetChance = 0;
                if (rankDiff === 1) upsetChance = 0.33;
                else if (rankDiff === 2) upsetChance = 0.15;
                else if (rankDiff === 3) upsetChance = 0.05;
                else if (rankDiff >= 4) upsetChance = 0.03;

                const higherRankTeam = rankValues[rank1] > rankValues[rank2] ? team1 : team2;
                const lowerRankTeam = rankValues[rank1] > rankValues[rank2] ? team2 : team1;
                const higherRank = rankValues[rank1] > rankValues[rank2] ? rank1 : rank2;
                const lowerRank = rankValues[rank1] > rankValues[rank2] ? rank2 : rank1;

                if (Math.random() < upsetChance) {
                    winnerName = lowerRankTeam;
                    loserName = higherRankTeam;
                    winnerRank = lowerRank;
                    loserRank = higherRank;
                    isUpset = true;
                    upsets.push({ winner: winnerName, loser: loserName, rankDiff });
                } else {
                    winnerName = higherRankTeam;
                    loserName = lowerRankTeam;
                    winnerRank = higherRank;
                    loserRank = lowerRank;
                }
            }
            
            let winnerScore, loserScore;
            if (isUpset) {
                winnerScore = 2 + Math.floor(Math.random() * 3); // 2-4
                loserScore = winnerScore - 1;
            } else {
                [winnerScore, loserScore] = generateAutoScore(winnerRank, loserRank);
            }

            match.score1 = (match.team1 === winnerName) ? winnerScore : loserScore;
            match.score2 = (match.team2 === winnerName) ? winnerScore : loserScore;
            await processMatchWin(matchId, winnerName);
        }
        
        let newsBody = `${roundNumber}回戦が全試合終了しました。\n順当に勝ち上がる強豪校もいれば、波乱の展開も見られました。\n次のラウンドではどのようなドラマが待っているのか、目が離せません！`;
        let bbsCommentText = `${roundNumber}回戦終わったかー。やっぱり上位ランクのチームは安定してるな。`;

        if (upsets.length > 0) {
            const biggestUpset = upsets.sort((a, b) => b.rankDiff - a.rankDiff)[0];
            newsBody = `${roundNumber}回戦が終了し、早くも波乱の展開！\n特に${biggestUpset.winner}が強豪${biggestUpset.loser}を破るジャイアントキリングを達成し、球場を沸かせました。\n次のラウンドも目が離せない！`;
            bbsCommentText = `まさか${biggestUpset.loser}が${roundNumber}回戦で負けるとは…今年の夏は何が起こるか分からんぞ。`;
        }
        
        const article = {
            title: `${roundNumber}回戦全試合が終了！`,
            body: newsBody,
            timestamp: Date.now()
        };
        
        tournamentState.news.push(article);
        tournamentState.bbsComments.push({
            id: crypto.randomUUID(),
            personality: "野球好き",
            text: bbsCommentText,
            timestamp: Date.now(),
            replies: []
        });

        skipLoader.classList.add('hidden');
        renderTournament(tournamentState);
        saveState();
    }

    function checkTournamentProgress() {
        if (tournamentState.is16team || !tournamentState.matches || Object.keys(tournamentState.matches).length === 0) {
            skipR1Btn.classList.add('hidden');
            skipR2Btn.classList.add('hidden');
            skipR3Btn.classList.add('hidden');
            return;
        }

        const matchIds = Object.keys(tournamentState.matches);
        const getRoundStatus = (roundNumber) => {
            const roundMatchIds = matchIds.filter(id => id.includes(`-R${roundNumber}-M`));
            const played = roundMatchIds.filter(id => tournamentState.matches[id] && tournamentState.matches[id].winner).length;
            const total = 32 / Math.pow(2, roundNumber - 1);
            return { total, played };
        };

        const r1 = getRoundStatus(1);
        const r2 = getRoundStatus(2);
        const r3 = getRoundStatus(3);

        skipR1Btn.classList.toggle('hidden', r1.played > 0);
        skipR2Btn.classList.toggle('hidden', !(r1.played === r1.total && r2.played === 0));
        skipR3Btn.classList.toggle('hidden', !(r2.played === r2.total && r3.played === 0));
        checkBest8Decided();
    }

    // --- Initial Load & Setup ---
    async function initializeApp() {
        const savedStateJSON = localStorage.getItem('tournamentState');
        if (savedStateJSON) {
            try {
                const lastState = JSON.parse(savedStateJSON);
                if (lastState && lastState.tournamentYear) {
                    const confirmed = await showConfirm("前回の続きから再開しますか？\n（「いいえ」を選択すると、最初から、または「合い言葉」で再開できます）");
                    if (confirmed) {
                        tournamentState = lastState;
                        setupEl.classList.add('hidden');
                        tournamentDisplayEl.classList.remove('hidden');

                        if (tournamentState.autumnPhase === 'regional') {
                            renderAutumnRegionalPhase();
                        } else {
                            renderTournament(tournamentState);
                        }
                        return; 
                    }
                }
            } catch (e) {
                console.error("保存されたデータの読み込みに失敗しました:", e);
                localStorage.removeItem('tournamentState'); 
            }
        }
        
        setupEl.classList.remove('hidden');
        tournamentDisplayEl.classList.add('hidden');
        teamsTextarea.value = INITIAL_TEAM_POOL.join('\n');
        resumeBtn.classList.remove('hidden');
    }

    generateBtn.addEventListener('click', async () => {
        const savedStateJSON = localStorage.getItem('tournamentState');
        if (savedStateJSON) {
            const confirmed = await showConfirm("新しいトーナメントを開始すると、保存されている進行状況は失われます。よろしいですか？");
            if (confirmed) {
                createNewTournament(false, 'summer');
            }
        } else {
            createNewTournament(false, 'summer');
        }
    });

    resumeBtn.addEventListener('click', () => {
        saveLoadModal.classList.remove('hidden');
        loadTabBtn.click();
    });

    nextTournamentBtn.addEventListener('click', () => {
        let nextTournamentType;
        // 夏の大会が終わった時だけ、世代交代処理を実行する
        if (tournamentState.currentTournament === 'summer') {
            runOffSeason();
            nextTournamentType = 'autumn';
        } else if (tournamentState.currentTournament === 'autumn') {
            nextTournamentType = 'spring';
        } else { // spring
            nextTournamentType = 'summer';
        }
        createNewTournament(true, nextTournamentType);
    });    
    resetBtn.addEventListener('click', async () => {
        const confirmed = await showConfirm("すべての大会記録をリセットして、最初の状態に戻しますか？");
        if(confirmed){
            localStorage.clear();
            location.reload();
        }
    });

    saveBtn.addEventListener('click', () => {
        document.getElementById('save-code-area').classList.add('hidden');
        saveLoadModal.classList.remove('hidden');
        saveTabBtn.click();
    });

    skipR1Btn.addEventListener('click', async () => {
        const confirmed = await showConfirm("1回戦の全試合をランクに基づいて自動で進行します。この操作は元に戻せません。よろしいですか？");
        if (confirmed) {
            skipRound(1);
        }
    });
    skipR2Btn.addEventListener('click', async () => {
        const confirmed = await showConfirm("2回戦の全試合をランクに基づいて自動で進行します。この操作は元に戻せません。よろしいですか？");
        if (confirmed) {
            skipRound(2);
        }
    });
    skipR3Btn.addEventListener('click', async () => {
        const confirmed = await showConfirm("3回戦の全試合をランクに基づいて自動で進行します。この操作は元に戻せません。よろしいですか？");
        if (confirmed) {
            skipRound(3);
        }
    });

    startPlayoffBtn.addEventListener('click', () => {
        // This button is currently unused in the new logic.
    });

    startMainTournamentBtn.addEventListener('click', async () => {
        const confirmed = await showConfirm("代表校が全て決定しました。県大会本戦に進みますか？");
        if (confirmed) {
            await setupAutumnMainTournament();
        }
    });
    
    // Modal close events
    modalBg.addEventListener('click', () => newsModal.classList.add('hidden'));
    modalClose.addEventListener('click', () => newsModal.classList.add('hidden'));
    document.getElementById('details-save').addEventListener('click', saveDetailedStats);
    document.getElementById('details-close').addEventListener('click', () => detailsModal.classList.add('hidden'));
    saveLoadCloseBtn.addEventListener('click', () => saveLoadModal.classList.add('hidden'));
    newspaperCloseBtn.addEventListener('click', () => newspaperModal.classList.add('hidden'));

    // Save/Load Tab Logic
    saveTabBtn.addEventListener('click', () => {
        saveTabBtn.classList.add('border-blue-500');
        saveTabBtn.classList.remove('text-gray-500');
        loadTabBtn.classList.remove('border-blue-500');
        loadTabBtn.classList.add('text-gray-500');
        saveTabContent.classList.remove('hidden');
        loadTabContent.classList.add('hidden');
    });

    loadTabBtn.addEventListener('click', () => {
        loadTabBtn.classList.add('border-blue-500');
        loadTabBtn.classList.remove('text-gray-500');
        saveTabBtn.classList.remove('border-blue-500');
        saveTabBtn.classList.add('text-gray-500');
        loadTabContent.classList.remove('hidden');
        saveTabContent.classList.add('hidden');
    });
    
    generateSaveCodeBtn.addEventListener('click', () => {
        const btn = generateSaveCodeBtn;
        btn.disabled = true;
        btn.textContent = '発行しています...';

        setTimeout(() => {
            try {
                const jsonString = JSON.stringify(tournamentState);
                const compressed = pako.deflate(jsonString);
                const base64 = uint8ArrayToBase64(compressed);
                document.getElementById('save-code-output').textContent = base64;
                document.getElementById('save-code-area').classList.remove('hidden');
                document.getElementById('copy-feedback').textContent = '';
            } catch(e) {
                console.error("合い言葉の生成に失敗:", e);
                showAlert("合い言葉の生成に失敗しました。");
            } finally {
                btn.disabled = false;
                btn.textContent = '合い言葉を発行';
            }
        }, 50);
    });

    copySaveCodeBtn.addEventListener('click', () => {
        const code = document.getElementById('save-code-output').textContent;
        const feedback = document.getElementById('copy-feedback');
        
        navigator.clipboard.writeText(code).then(() => {
            feedback.textContent = 'コピーしました！';
            setTimeout(() => {
                feedback.textContent = '';
            }, 2000);
        });
    });

    loadFromCodeBtn.addEventListener('click', () => {
        const btn = loadFromCodeBtn;
        btn.disabled = true;
        btn.textContent = '読み込んでいます...';

        setTimeout(() => {
            const code = document.getElementById('load-code-input').value;
            if (!code) {
                showAlert('合い言葉を入力してください。');
                btn.disabled = false;
                btn.textContent = 'このデータで再開する';
                return;
            }

            try {
                const binaryString = atob(code);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                const decompressedBytes = pako.inflate(bytes);
                if (!decompressedBytes) {
                    throw new Error("Decompression failed. The save code might be corrupted.");
                }
                const decompressedString = new TextDecoder("utf-8").decode(decompressedBytes);
                const loadedState = JSON.parse(decompressedString);

                tournamentState = loadedState;
                saveState(); // Update main localStorage slot
                
                setupEl.classList.add('hidden');
                tournamentDisplayEl.classList.remove('hidden');

                
                if (tournamentState.autumnPhase === 'regional') {
                    renderAutumnRegionalPhase();
                } else {
                    renderTournament(tournamentState);
                }
                
                saveLoadModal.classList.add('hidden');

            } catch (e) {
                console.error("データの読み込みに失敗:", e);
                showAlert("データの読み込みに失敗しました。合い言葉が間違っているか、データが破損している可能性があります。");
            } finally {
                btn.disabled = false;
                btn.textContent = 'このデータで再開する';
            }
        }, 50);
    });

    generateSummaryBtn.addEventListener('click', async () => {
        generateSummaryBtn.disabled = true;
        generateSummaryBtn.textContent = '記事を生成中...';
        newsContainer.innerHTML = `<div class="loader">AI記者がハイライト記事を執筆中...</div>`;

        const summaryArticle = await generateBest8PreviewArticle();

        if (summaryArticle) {
            tournamentState.news.push(summaryArticle);
            saveState();
            renderNews(tournamentState.news);
        }
        
        generateSummaryBtn.classList.add('hidden');
        generateSummaryBtn.disabled = false;
        generateSummaryBtn.textContent = 'ベスト8ハイライト記事を生成';
    });

   
// --- ▼ここからコピー▼ ---

const ROSTER_DATA = {
    "西浦": {
        pitchers: [
            { name: "三橋 廉", year: 1, hand: "右", maxSpeed: 128, control: 95, stamina: 98, slider: 4, curve: 5, "シュート": 3, special: "驚異的なコントロール" },
            { name: "沖", year: 1, hand: "右", maxSpeed: 125, control: 60, stamina: 55, slider: 2 }
        ],
        batters: [
            { name: "阿部 隆也", year: 1, pos: "捕", hand: "右", meet: 60, power: 55, run: 60, defense: "A", special: "インサイドワーク" },
            { name: "田島 悠一郎", year: 1, pos: "三", hand: "両", meet: 90, power: 75, run: 95, defense: "B", special: "天才的なバッティングセンス" },
            { name: "花井 梓", year: 1, pos: "右", hand: "右", meet: 70, power: 80, run: 70, defense: "C" },
            { name: "泉 孝介", year: 1, pos: "中", hand: "左", meet: 75, power: 60, run: 85, defense: "B" },
            { name: "栄口 勇人", year: 1, pos: "二", hand: "右", meet: 65, power: 50, run: 70, defense: "B", special: "堅実な守備" },
            { name: "水谷 文貴", year: 1, pos: "左", hand: "右", meet: 50, power: 40, run: 65, defense: "D" },
            { name: "巣山 尚治", year: 1, pos: "遊", hand: "右", meet: 60, power: 65, run: 60, defense: "C" },
            { name: "西広 辰太郎", year: 1, pos: "一", hand: "右", meet: 40, power: 30, run: 50, defense: "C" }
        ]
    },
    "283学園": {
        pitchers: [
            { name: "姫川 友紀", year: 3, hand: "右", maxSpeed: 151, control: 82, stamina: 90, "スプリット": 6, slider: 4, special: "投打の怪物" },
            { name: "天海 晴彦", year: 2, hand: "右", maxSpeed: 155, control: 70, stamina: 75, slider: 5, special: "チーム最速ストレート" },
            { name: "松本 晴康", year: 3, hand: "左", maxSpeed: 145, control: 88, stamina: 80, "サークルチェンジ": 5, curve: 4, special: "春の大会で完全試合達成" }
        ],
        batters: [
            { name: "花海 雄介", year: 3, pos: "中", hand: "右", meet: 85, power: 80, run: 92, defense: "A", special: "走攻守三拍子揃ったリードオフマン" },
            { name: "鈴木 佐奈", year: 2, pos: "一", hand: "左", meet: 90, power: 85, run: 60, defense: "B", special: "芯で捉える技術" },
            { name: "十王 星南", year: 3, pos: "遊", hand: "右", meet: 80, power: 70, run: 88, defense: "S", special: "鉄壁の守備" },
            { name: "浅倉 亨", year: 2, pos: "左", hand: "右", meet: 75, power: 90, run: 70, defense: "B", special: "クラッチヒッター" },
            { name: "島村 海斗", year: 3, pos: "三", hand: "右", meet: 70, power: 92, run: 65, defense: "B", special: "強肩強打" },
            { name: "有栖川 悠覇", year: 3, pos: "捕", hand: "右", meet: 88, power: 82, run: 60, defense: "A", special: "大舞台に強い主軸" },
            { name: "芹沢 優吾", year: 2, pos: "二", hand: "右", meet: 78, power: 65, run: 80, defense: "B", special: "小技と守備センス" },
            { name: "花海 佑樹", year: 1, pos: "右", hand: "左", meet: 82, power: 88, run: 85, defense: "A", special: "スーパールーキー" }
        ]
    },
     "代矢東": {
        pitchers: [
            { name: "渋谷 卓", year: 3, hand: "右", maxSpeed: 152, control: 85, stamina: 88, slider: 5, fork: 4, special: "本格派エース" },
            { name: "六反田 良弥", year: 3, hand: "右", maxSpeed: 150, control: 78, stamina: 80, cutter: 4, special: "リリーフもこなす剛腕" },
            { name: "鳥羽 晴康", year: 3, hand: "左", maxSpeed: 144, control: 90, stamina: 75, screw: 5, special: "技巧派クローザー" }
        ],
        batters: [
            { name: "片野坂 晴人", year: 3, pos: "捕", hand: "右", meet: 80, power: 78, run: 70, defense: "S", special: "強肩強打の司令塔" },
            { name: "郷野 将暉", year: 3, pos: "一", hand: "左", meet: 75, power: 95, run: 60, defense: "B", special: "プロ注目スラッガー" },
            { name: "片倉 郁弥", year: 3, pos: "二", hand: "右", meet: 85, power: 65, run: 90, defense: "A", special: "俊足の守備職人" },
            { name: "島津 成哉", year: 3, pos: "三", hand: "右", meet: 82, power: 80, run: 75, defense: "A", special: "強肩と広角打法" },
            { name: "藤原 元輝", year: 3, pos: "遊", hand: "右", meet: 78, power: 70, run: 85, defense: "A", special: "軽快なフットワーク" },
            { name: "倉科 哲史", year: 3, pos: "左", hand: "左", meet: 88, power: 72, run: 82, defense: "B", special: "高い身体能力" },
            { name: "滝川 文隆", year: 3, pos: "中", hand: "左", meet: 90, power: 68, run: 94, defense: "A", special: "抜群の走力を持つリードオフマン" },
            { name: "川又 良太", year: 3, pos: "右", hand: "右", meet: 84, power: 75, run: 78, defense: "B", special: "安定したアベレージヒッター" }
        ]
    },
    "稲城実業": {
        pitchers: [
            { name: "成宮 鳴", year: 3, hand: "左", maxSpeed: 150, control: 92, stamina: 94, "チェンジアップ": 7, slider: 5, special: "世代最強左腕『キング』" },
            { name: "平野 瞬", year: 2, hand: "右", maxSpeed: 148, control: 80, stamina: 82, fork: 5 },
            { name: "赤松 晋二", year: 1, hand: "右", maxSpeed: 152, control: 75, stamina: 78, slider: 4, special: "期待の1年生剛腕" }
        ],
        batters: [
            { name: "多田野 樹", year: 2, pos: "捕", hand: "右", meet: 78, power: 75, run: 65, defense: "A", special: "冷静なリード" },
            { name: "神谷 カルロス 俊樹", year: 3, pos: "中", hand: "右", meet: 80, power: 82, run: 98, defense: "A", special: "俊足の『チーター』" },
            { name: "白河 勝之", year: 3, pos: "遊", hand: "右", meet: 88, power: 78, run: 85, defense: "S", special: "卓越した野球センス" },
            { name: "山岡 陸", year: 3, pos: "三", hand: "右", meet: 82, power: 94, run: 70, defense: "B", special: "新4番のクラッチヒッター" },
            { name: "矢部 明雄", year: 2, pos: "右", hand: "右", meet: 75, power: 68, run: 90, defense: "B" }
        ]
    }
    // 他の注目校のデータも同様に追加できます
};

// --- ここまでコピー ---
// --- ▼ここからコピー▼ ---

/**
 * ゲーム開始時に、全チームの選手情報（ロースター）を初期化する。
 * ROSTER_DATAに定義がないチームは、ランダムな選手を自動生成する。
 */
function initializeFullRoster() {
    tournamentState.playerRoster = {}; // まず名簿を空にする

    const teamNames = INITIAL_TEAM_POOL;
    teamNames.forEach(teamName => {
        if (ROSTER_DATA[teamName]) {
            // ROSTER_DATAに定義済みのチームは、そのデータをコピーして使用
            tournamentState.playerRoster[teamName] = JSON.parse(JSON.stringify(ROSTER_DATA[teamName]));
        } else {
            // データがないチームは、学校ランクに応じた選手を自動生成
            tournamentState.playerRoster[teamName] = generateRandomPlayers(teamName);
        }
    });
}

/**
 * 指定されたチーム名とランクに基づき、ランダムな選手団を生成する。
 * @param {string} teamName - 選手を生成するチームの名前
 * @returns {{pitchers: Array, batters: Array}} - 生成された選手リスト
 */
function generateRandomPlayers(teamName) {
    const teamRank = calculateRank(teamName, { teamRecords: {} }); // 初期ランクを計算
    const pitchers = [];
    const batters = [];

    // ランクに応じた能力値の基準を設定
    const baseAbility = { 'A': 75, 'B': 65, 'C': 55, 'D': 45, 'E': 35 }[teamRank];

    const numPitchers = 2 + Math.floor(Math.random() * 3); // 2〜4人の投手
    const numBatters = 9 + Math.floor(Math.random() * 5); // 9〜13人の野手

    // ランダムな日本人名を生成するためのリスト
    const lastNames = ["佐藤", "鈴木", "高橋", "田中", "渡辺", "伊藤", "中村", "山本", "小林", "加藤", "吉田", "山田", "佐々木", "山口", "松本", "井上", "木村", "林", "斎藤", "清水"];
    const firstNames = ["翔太", "蓮", "陽翔", "蒼", "湊", "樹", "大和", "悠真", "陽菜", "凛", "結菜", "芽依", "陽葵", "杏", "さくら", "莉子"];

    for (let i = 0; i < numPitchers; i++) {
        const randomName = lastNames[Math.floor(Math.random() * lastNames.length)] + " " + firstNames[Math.floor(Math.random() * firstNames.length)];
        pitchers.push({
            name: randomName,
            year: Math.ceil(Math.random() * 3), // 1〜3年生
            hand: Math.random() > 0.2 ? "右" : "左",
            maxSpeed: 120 + Math.floor(baseAbility / 4 + Math.random() * 15),
            control: baseAbility - 10 + Math.floor(Math.random() * 20),
            stamina: baseAbility - 10 + Math.floor(Math.random() * 20),
            slider: Math.floor(Math.random() * 5) // 変化球は簡易的に
        });
    }

    const positions = ["捕", "一", "二", "三", "遊", "左", "中", "右", "捕", "内", "外"];
    for (let i = 0; i < numBatters; i++) {
        const randomName = lastNames[Math.floor(Math.random() * lastNames.length)] + " " + firstNames[Math.floor(Math.random() * firstNames.length)];
        batters.push({
            name: randomName,
            year: Math.ceil(Math.random() * 3),
            pos: positions[i % positions.length],
            hand: Math.random() > 0.3 ? "右" : "左",
            meet: baseAbility - 15 + Math.floor(Math.random() * 30),
            power: baseAbility - 15 + Math.floor(Math.random() * 30),
            run: baseAbility - 15 + Math.floor(Math.random() * 30),
            defense: ["D", "C", "B", "A", "S"][Math.floor(baseAbility / 20)] // ランクから守備力も簡易査定
        });
    }

    return { pitchers, batters };
}

// --- ここまでコピー ---
// --- ▼ここからコピー▼ ---

// --- Player Directory Elements ---
const directoryBtn = document.getElementById('directory-btn');
const directoryModal = document.getElementById('player-directory-modal');
const directoryModalTitle = document.getElementById('directory-modal-title');
const directoryModalContent = document.getElementById('directory-modal-content');
const directoryModalClose = document.getElementById('directory-modal-close');

/**
 * 選手名鑑モーダルを開き、チーム一覧を表示する
 */
function openPlayerDirectory() {
    directoryModalTitle.textContent = '選手名鑑';
    let contentHtml = '<div class="grid grid-cols-2 md:grid-cols-4 gap-4">';

    INITIAL_TEAM_POOL.forEach(teamName => {
        const teamRank = calculateRank(teamName, tournamentState);
        contentHtml += `
            <div class="p-3 border rounded-lg hover:bg-gray-100 hover:border-blue-500 cursor-pointer team-select-btn" data-team-name="${teamName}">
                <span class="font-bold text-sm">[${teamRank}]</span>
                <span class="font-semibold">${teamName}</span>
            </div>
        `;
    });

    contentHtml += '</div>';
    directoryModalContent.innerHTML = contentHtml;
    directoryModal.classList.remove('hidden');
    directoryModal.classList.add('flex');
}

/**
 * 指定されたチームの選手一覧（ロースター）を表示する
 * @param {string} teamName 表示するチーム名
 */
function renderTeamRoster(teamName) {
    const roster = tournamentState.playerRoster[teamName];
    if (!roster) return;

    directoryModalTitle.textContent = `${teamName} 選手一覧`;

    let contentHtml = `
        <button id="back-to-teams-btn" class="mb-4 bg-gray-500 text-white px-3 py-1 rounded hover:bg-gray-600 text-sm">← チーム一覧に戻る</button>

        <h4 class="text-lg font-bold mb-2 text-red-600">投手</h4>
        <div class="overflow-x-auto">
            <table class="min-w-full bg-white border">
                <thead class="bg-gray-100">
                    <tr>
                        <th class="py-2 px-3 border-b text-left">名前</th><th class="py-2 px-3 border-b">学年</th><th class="py-2 px-3 border-b">投</th><th class="py-2 px-3 border-b">MAX</th><th class="py-2 px-3 border-b">ｺﾝﾄﾛｰﾙ</th><th class="py-2 px-3 border-b">ｽﾀﾐﾅ</th><th class="py-2 px-3 border-b text-left">変化球</th>
                    </tr>
                </thead>
                <tbody>
                    ${roster.pitchers.map(p => `
                        <tr class="hover:bg-gray-50">
                            <td class="py-2 px-3 border-b">${p.name}${p.special ? ` <span class="text-xs text-yellow-600 font-bold">${p.special}</span>` : ''}</td>
                            <td class="py-2 px-3 border-b text-center">${p.year}</td><td class="py-2 px-3 border-b text-center">${p.hand}</td>
                            <td class="py-2 px-3 border-b text-center">${p.maxSpeed}km/h</td><td class="py-2 px-3 border-b text-center">${p.control}</td><td class="py-2 px-3 border-b text-center">${p.stamina}</td>
                            <td class="py-2 px-3 border-b text-sm">${Object.entries(p).filter(([key, val]) => !["name","year","hand","maxSpeed","control","stamina","special"].includes(key) && val > 0).map(([key, val]) => `${key}${val}`).join(' ')}</td>
                        </tr>
                    `).join('')}
                </tbody>
            </table>
        </div>

        <h4 class="text-lg font-bold mt-6 mb-2 text-blue-600">野手</h4>
        <div class="overflow-x-auto">
            <table class="min-w-full bg-white border">
                <thead class="bg-gray-100">
                    <tr>
                        <th class="py-2 px-3 border-b text-left">名前</th><th class="py-2 px-3 border-b">学年</th><th class="py-2 px-3 border-b">守</th><th class="py-2 px-3 border-b">打</th><th class="py-2 px-3 border-b">ﾐｰﾄ</th><th class="py-2 px-3 border-b">ﾊﾟﾜｰ</th><th class="py-2 px-3 border-b">走力</th><th class="py-2 px-3 border-b">守備</th>
                    </tr>
                </thead>
                <tbody>
                     ${roster.batters.map(b => `
                        <tr class="hover:bg-gray-50">
                            <td class="py-2 px-3 border-b">${b.name}${b.special ? ` <span class="text-xs text-yellow-600 font-bold">${b.special}</span>` : ''}</td>
                            <td class="py-2 px-3 border-b text-center">${b.year}</td><td class="py-2 px-3 border-b text-center">${b.pos}</td><td class="py-2 px-3 border-b text-center">${b.hand}</td>
                            <td class="py-2 px-3 border-b text-center">${b.meet}</td><td class="py-2 px-3 border-b text-center">${b.power}</td><td class="py-2 px-3 border-b text-center">${b.run}</td><td class="py-2 px-3 border-b text-center font-bold">${b.defense}</td>
                        </tr>
                    `).join('')}
                </tbody>
            </table>
        </div>
    `;
    directoryModalContent.innerHTML = contentHtml;
}

// --- Event Listeners for Directory ---
directoryBtn.addEventListener('click', openPlayerDirectory);
directoryModalClose.addEventListener('click', () => directoryModal.classList.add('hidden'));

directoryModalContent.addEventListener('click', (e) => {
    const teamBtn = e.target.closest('.team-select-btn');
    const backBtn = e.target.closest('#back-to-teams-btn');

    if (teamBtn) {
        const teamName = teamBtn.dataset.teamName;
        renderTeamRoster(teamName);
    } else if (backBtn) {
        openPlayerDirectory(); // チーム一覧に戻る
    }
});


// --- ここまでコピー ---
// --- ▼ここからコピー▼ ---

/**
 * 2チーム間の試合をシミュレートし、詳細なボックススコアを生成する
 * @param {string} team1Name チーム1の名前
 * @param {string} team2Name チーム2の名前
 * @returns {object} スコアと個人成績を含むボックススコアオブジェクト
 */
function simulateGame(team1Name, team2Name) {
    const roster1 = tournamentState.playerRoster[team1Name];
    const roster2 = tournamentState.playerRoster[team2Name];

    // 簡単なチーム力の計算
    const getTeamPower = (roster) => {
        const batPower = roster.batters.reduce((acc, p) => acc + p.meet + p.power, 0) / roster.batters.length;
        const pitPower = roster.pitchers[0].control + roster.pitchers[0].stamina - (150 - roster.pitchers[0].maxSpeed);
        return { offense: batPower, defense: pitPower };
    };

    const power1 = getTeamPower(roster1);
    const power2 = getTeamPower(roster2);

    let boxScore = {
        [team1Name]: { runs: 0, hits: 0, errors: 0, inningScores: [] },
        [team2Name]: { runs: 0, hits: 0, errors: 0, inningScores: [] },
        pitcherStats: { [team1Name]: [], [team2Name]: [] },
        batterStats: { [team1Name]: {}, [team2Name]: {} }
    };

    // 全選手の打撃成績を初期化
    roster1.batters.forEach(p => boxScore.batterStats[team1Name][p.name] = { atBats: 0, hits: 0, rbi: 0, hr: 0 });
    roster2.batters.forEach(p => boxScore.batterStats[team2Name][p.name] = { atBats: 0, hits: 0, rbi: 0, hr: 0 });

    let currentInning = 1;
    while (currentInning <= 9 || boxScore[team1Name].runs === boxScore[team2Name].runs) {
        // --- 表の攻撃 (team1) ---
        let inningRuns1 = 0;
        let offensePower = power1.offense + (Math.random() * 20 - 10);
        let defensePower = power2.defense + (Math.random() * 20 - 10);
        if (offensePower > defensePower) {
            inningRuns1 = Math.floor(Math.random() * (1 + (offensePower - defensePower) / 25));
        }
        boxScore[team1Name].inningScores.push(inningRuns1);
        boxScore[team1Name].runs += inningRuns1;

        // --- 裏の攻撃 (team2) ---
         let inningRuns2 = 0;
        offensePower = power2.offense + (Math.random() * 20 - 10);
        defensePower = power1.defense + (Math.random() * 20 - 10);
        if (offensePower > defensePower) {
            inningRuns2 = Math.floor(Math.random() * (1 + (offensePower - defensePower) / 25));
        }
        boxScore[team2Name].inningScores.push(inningRuns2);
        boxScore[team2Name].runs += inningRuns2;
        
        currentInning++;
    }

    // ヒット数などをそれらしく計算
    boxScore[team1Name].hits = Math.floor(boxScore[team1Name].runs * (1 + Math.random()));
    boxScore[team2Name].hits = Math.floor(boxScore[team2Name].runs * (1 + Math.random()));

    // 簡易的な個人成績の割り振り
    for(let i=0; i<boxScore[team1Name].hits; i++){
        const batter = roster1.batters[Math.floor(Math.random()*roster1.batters.length)];
        boxScore.batterStats[team1Name][batter.name].hits++;
    }
     for(let i=0; i<boxScore[team2Name].hits; i++){
        const batter = roster2.batters[Math.floor(Math.random()*roster2.batters.length)];
        boxScore.batterStats[team2Name][batter.name].hits++;
    }
    
    // 最終スコアと勝者を確定
    boxScore.winner = boxScore[team1Name].runs > boxScore[team2Name].runs ? team1Name : team2Name;
    boxScore.loser = boxScore.winner === team1Name ? team2Name : team1Name;
    boxScore.score1 = boxScore[team1Name].runs;
    boxScore.score2 = boxScore[team2Name].runs;

    return boxScore;
}
// --- ここまでコピー ---
// --- ▼ここからコピー▼ ---

/**
 * オフシーズンの処理（世代交代）を実行する
 */
function runOffSeason() {
    retireThirdGraders();
    advanceGrades();
    addNewPlayers();
    alert("夏の大会が終了し、3年生が引退。新チームが始動しました！");
}

/**
 * 全チームの3年生を引退させる
 */
function retireThirdGraders() {
    for (const teamName in tournamentState.playerRoster) {
        const roster = tournamentState.playerRoster[teamName];
        roster.pitchers = roster.pitchers.filter(p => p.year !== 3);
        roster.batters = roster.batters.filter(p => p.year !== 3);
    }
}

/**
 * 残った全選手の学年を1つ上げる
 */
function advanceGrades() {
    for (const teamName in tournamentState.playerRoster) {
        const roster = tournamentState.playerRoster[teamName];
        roster.pitchers.forEach(p => p.year++);
        roster.batters.forEach(p => p.year++);
    }
}

/**
 * 全チームに新1年生を追加する
 */
function addNewPlayers() {
    // ランダムな日本人名を生成するためのリスト
    const lastNames = ["青木", "石井", "内田", "遠藤", "岡田", "長谷川", "原田", "前田", "藤本", "森", "小川", "後藤", "近藤", "坂本", "石川", "橋本", "工藤", "菊地", "西村", "村上"];
    const firstNames = ["悠", "颯太", "大輝", "陸", "健太", "拓海", "航平", "駿", "美咲", "葵", "彩乃", "楓", "優奈", "穂乃花", "愛梨", "純"];

    for (const teamName in tournamentState.playerRoster) {
        const roster = tournamentState.playerRoster[teamName];
        const teamRank = calculateRank(teamName, tournamentState);
        const baseAbility = { 'A': 70, 'B': 60, 'C': 50, 'D': 40, 'E': 30 }[teamRank];
        const numNewPlayers = 7 + Math.floor(Math.random() * 5); // 7〜11人の新入生

        for (let i = 0; i < numNewPlayers; i++) {
            const randomName = lastNames[Math.floor(Math.random() * lastNames.length)] + " " + firstNames[Math.floor(Math.random() * firstNames.length)];
            // 30%の確率で投手、70%の確率で野手を作成
            if (Math.random() < 0.3) {
                 roster.pitchers.push({
                    name: randomName, year: 1, hand: Math.random() > 0.2 ? "右" : "左",
                    maxSpeed: 115 + Math.floor(baseAbility / 4 + Math.random() * 15),
                    control: baseAbility - 15 + Math.floor(Math.random() * 30),
                    stamina: baseAbility - 15 + Math.floor(Math.random() * 30),
                    slider: Math.floor(Math.random() * 4)
                });
            } else {
                const positions = ["捕", "一", "二", "三", "遊", "左", "中", "右"];
                roster.batters.push({
                    name: randomName, year: 1, pos: positions[Math.floor(Math.random() * positions.length)],
                    hand: Math.random() > 0.3 ? "右" : "左",
                    meet: baseAbility - 15 + Math.floor(Math.random() * 30),
                    power: baseAbility - 15 + Math.floor(Math.random() * 30),
                    run: baseAbility - 15 + Math.floor(Math.random() * 30),
                    defense: ["E", "D", "C", "B", "A"][Math.floor(baseAbility / 20)]
                });
            }
        }
        // 1%の確率で「天才」を一人追加
        if(Math.random() < 0.01) {
            const randomName = lastNames[Math.floor(Math.random() * lastNames.length)] + " " + firstNames[Math.floor(Math.random() * firstNames.length)];
            roster.batters.push({
                    name: randomName, year: 1, pos: "遊", hand: "両", meet: 80, power: 80, run: 80, defense: "A", special: "天才"
            });
        }
    }
}

// --- ここまでコピー ---
initializeApp();
</script>
       </body>
</html>